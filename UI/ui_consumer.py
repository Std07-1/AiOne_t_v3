"""UI –∫–æ–Ω—Å—é–º–µ—Ä —É —Ä–µ–∂–∏–º—ñ render-only: –±–µ–∑ –ª–æ–∫–∞–ª—å–Ω–∏—Ö –æ–±—á–∏—Å–ª–µ–Ω—å —Ü—ñ–Ω/ATR/RSI/TP-SL."""

import asyncio
import json
import logging
import os
import time
from datetime import datetime
from typing import Any, Literal, cast

import redis.asyncio as redis
from rich.box import ROUNDED
from rich.console import Console
from rich.live import Live
from rich.logging import RichHandler
from rich.table import Table

from config.config import (
    K_SIGNAL,
    K_STATS,
    K_SYMBOL,
    K_TRIGGER_REASONS,
    REDIS_CHANNEL_ASSET_STATE,
    REDIS_CHANNEL_UI_ASSET_STATE,
    REDIS_SNAPSHOT_KEY,
    REDIS_SNAPSHOT_UI_KEY,
    UI_USE_V2_NAMESPACE,
)

ui_console = Console(stderr=False)

ui_logger = logging.getLogger("ui_consumer")
ui_logger.setLevel(logging.INFO)
ui_logger.handlers.clear()
ui_logger.addHandler(RichHandler(console=Console(stderr=True), show_path=False))
ui_logger.propagate = False


class AlertAnimator:
    def __init__(self) -> None:
        self.active_alerts: dict[str, float] = {}

    def add_alert(self, symbol: str) -> None:
        self.active_alerts[symbol] = time.time()

    def should_highlight(self, symbol: str) -> bool:
        ts = self.active_alerts.get(symbol)
        if ts is None:
            return False
        if (time.time() - ts) < 8.0:
            return True
        self.active_alerts.pop(symbol, None)
        return False


class UIConsumer:
    def __init__(self, vol_z_threshold: float = 2.5, low_atr_threshold: float = 0.005):
        self.vol_z_threshold = vol_z_threshold
        self.low_atr_threshold = low_atr_threshold
        self.alert_animator = AlertAnimator()
        self.last_update_time: float = time.time()
        # –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –ø—Ä–∏–π–Ω—è—Ç–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç—É (–¥–ª—è –≤—ñ–¥—Å—ñ–∫–∞–Ω–Ω—è –∑–∞—Å—Ç–∞—Ä—ñ–ª–∏—Ö)
        self._last_seq: int = -1
        self._last_counters: dict[str, Any] = {}
        self._display_results: list[dict[str, Any]] = (
            []
        )  # –∫–µ—à –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –Ω–µ–ø–æ—Ä–æ–∂–Ω—å–æ–≥–æ —Å–ø–∏—Å–∫—É
        self._blink_state = False  # –¥–ª—è –º–∏–≥–æ—Ç—ñ–Ω–Ω—è pressure
        self._pressure_alert_active = False

    # self._last_core_refresh: float = 0.0  # –≤–∏–¥–∞–ª–µ–Ω–æ: Core/Health –±—ñ–ª—å—à–µ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è

    # Render-only —Ä–µ–∂–∏–º: UI –Ω–µ —Ñ–æ—Ä–º–∞—Ç—É—î —Ç–∞ –Ω–µ –æ–±—á–∏—Å–ª—é—î –∑–Ω–∞—á–µ–Ω–Ω—è ‚Äî –ª–∏—à–µ —Å—Ç–∏–ª—ñ–∑—É—î

    def _get_rsi_color(self, rsi: float) -> str:
        if rsi < 30:
            return "green"
        if rsi < 50:
            return "light_green"
        if rsi < 70:
            return "yellow"
        return "red"

    def _get_atr_color(self, atr_pct: float) -> str:
        if atr_pct < self.low_atr_threshold:
            return "red"
        if atr_pct > 0.02:
            return "yellow"
        return ""

    def _get_signal_icon(self, signal: str) -> str:
        icons = {
            "ALERT": "üî¥",
            "NORMAL": "üü¢",
            "ALERT_BUY": "üü¢‚Üë",
            "ALERT_SELL": "üî¥‚Üì",
            "NONE": "‚ö™",
        }
        return icons.get(signal, "‚ùì")

    def _get_recommendation_icon(self, recommendation: str) -> str:
        icons = {
            "STRONG_BUY": "üü¢‚Üë‚Üë",
            "BUY_IN_DIPS": "üü¢‚Üë",
            "HOLD": "üü°",
            "SELL_ON_RALLIES": "üî¥‚Üì",
            "STRONG_SELL": "üî¥‚Üì‚Üì",
            "AVOID": "‚ö´",
            "WAIT": "‚ö™",
        }
        return icons.get(recommendation, "")

    def _format_band_pct(self, asset: dict[str, Any]) -> str:
        """–ü–æ–≤–µ—Ä—Ç–∞—î —Ä—è–¥–æ–∫ —ñ–∑ Band% –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —É —Ç–∞–±–ª–∏—Ü—ñ."""

        band_raw: float | None = None
        try:
            root_band = asset.get("band_pct")
            if isinstance(root_band, (int, float)):
                band_raw = float(root_band)
            else:
                analytics = asset.get("analytics")
                if isinstance(analytics, dict):
                    band_candidate = analytics.get("corridor_band_pct")
                    if isinstance(band_candidate, (int, float)):
                        band_raw = float(band_candidate)
        except Exception:
            band_raw = None

        if band_raw is None or band_raw < 0:
            return "-"

        band_pct_val = band_raw * 100.0 if band_raw <= 1.0 else band_raw

        try:
            if band_pct_val < 0.3:
                band_color = "red"
            elif band_pct_val <= 1.5:
                band_color = "yellow"
            else:
                band_color = "green"
            return f"[{band_color}]{band_pct_val:.2f}%[/]"
        except Exception:
            return f"{band_pct_val:.2f}%"

    async def redis_consumer(
        self,
        redis_url: str | None = None,
        channel: str | None = None,
        refresh_rate: float = 0.8,
        loading_delay: float = 1.5,
        smooth_delay: float = 0.05,
    ) -> None:
        """
        –°–ª—É—Ö–∞—î –∫–∞–Ω–∞–ª Redis Pub/Sub, –ø—Ä–∏–π–º–∞—î payload {"meta","counters","assets"}
        —ñ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–∞–±–ª–∏—Ü—é.
        """
        # –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –∫–æ–Ω—Ñ—ñ–≥—ñ–≤ –∑ ENV, —â–æ–± –Ω–µ –ø—Ä–æ–º–∞—Ö–Ω—É—Ç–∏—Å—å –ø–æ —ñ–Ω—Å—Ç–∞–Ω—Å—É Redis
        redis_url = (
            redis_url
            or os.getenv("REDIS_URL")
            or f"redis://{os.getenv('REDIS_HOST','localhost')}:{os.getenv('REDIS_PORT','6379')}/0"
        )

        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ–≥–æ —Å–ø–∏—Å–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ (instance-level) –∑ —Ç–∏–ø–æ–º
        if not hasattr(self, "_last_results"):
            self._last_results: list[dict[str, Any]] = []

        redis_client = redis.from_url(
            redis_url, decode_responses=True, encoding="utf-8"
        )
        pubsub = redis_client.pubsub()

        # –°–ø—Ä–æ–±–∞ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç—É –ø–µ—Ä–µ–¥ –ø—ñ–¥–ø–∏—Å–∫–æ—é (cold start only)
        try:
            primary_snapshot = (
                REDIS_SNAPSHOT_UI_KEY if UI_USE_V2_NAMESPACE else REDIS_SNAPSHOT_KEY
            )
            fallback_snapshot = (
                REDIS_SNAPSHOT_KEY if UI_USE_V2_NAMESPACE else REDIS_SNAPSHOT_UI_KEY
            )
            snapshot_raw = await redis_client.get(primary_snapshot)
            if not snapshot_raw:
                snapshot_raw = await redis_client.get(fallback_snapshot)
            if snapshot_raw:
                snap = json.loads(snapshot_raw)
                if isinstance(snap, dict) and isinstance(snap.get("assets"), list):
                    self._last_results = snap.get("assets") or []
                    if self._last_results:
                        self._display_results = self._last_results
                    self._last_counters = snap.get("counters", {}) or {}
                    meta_ts = snap.get("meta", {}).get("ts")
                    meta_seq = snap.get("meta", {}).get("seq")
                    if meta_ts:
                        try:
                            # –Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç—É—î–º–æ UTC-—á–∞—Å –∫–æ—Ä–µ–∫—Ç–Ω–æ (Z ‚Üí +00:00)
                            self.last_update_time = datetime.fromisoformat(
                                str(meta_ts).replace("Z", "+00:00")
                            ).timestamp()
                        except Exception:
                            pass
                    try:
                        if meta_seq is not None:
                            self._last_seq = int(meta_seq)
                    except Exception:
                        pass
                    ui_logger.info(
                        "üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç: %d –∞–∫—Ç–∏–≤—ñ–≤",
                        len(self._last_results),
                    )
        except Exception:  # broad-except: –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∏–π
            ui_logger.debug("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç", exc_info=True)

        await asyncio.sleep(loading_delay)
        # –í–∏–±—ñ—Ä –∫–∞–Ω–∞–ª—É –∑–∞ namespace –∞–±–æ —è–≤–Ω–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º
        selected_channel: str = (
            channel
            if isinstance(channel, str) and channel
            else (
                REDIS_CHANNEL_UI_ASSET_STATE
                if UI_USE_V2_NAMESPACE
                else REDIS_CHANNEL_ASSET_STATE
            )
        )
        await pubsub.subscribe(selected_channel)
        ui_logger.info(
            f"üîó –ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Redis ({redis_url}), –∫–∞–Ω–∞–ª '{selected_channel}'..."
        )

        # –ü–æ—á–∞—Ç–∫–æ–≤–µ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è: —è–∫—â–æ –≤–∂–µ —î —Å–Ω–∞–ø—à–æ—Ç, –ø–æ–∫–∞–∑—É—î–º–æ –π–æ–≥–æ –æ–¥—Ä–∞–∑—É
        initial_results = self._display_results if self._display_results else []
        with Live(
            self._build_signal_table(
                initial_results, loading=not bool(initial_results)
            ),
            console=ui_console,
            refresh_per_second=refresh_rate,
            screen=False,
            transient=False,
        ) as live:
            while True:
                try:
                    # Periodic fallback snapshot reload ‚Äî –≤–∏–¥–∞–ª–µ–Ω–æ.
                    # Snapshot –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ª–∏—à–µ –ø—Ä–∏ —Ö–æ–ª–æ–¥–Ω–æ–º—É —Å—Ç–∞—Ä—Ç—ñ –∞–±–æ –ø—Ä–∏ gap —É seq.
                    message = await pubsub.get_message(
                        ignore_subscribe_messages=True, timeout=1.0
                    )
                    if message:
                        try:
                            data = json.loads(message["data"])
                        except Exception:
                            ui_logger.error(
                                "–ù–µ–≤–¥–∞—á–∞ json.loads –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"
                            )
                            data = None

                        # ‚úÖ –û—á—ñ–∫—É—î–º–æ dict –∑ 'assets' —Ç–∞ –∫–æ—Ä–µ–∫—Ç–Ω–æ—é meta.seq
                        if isinstance(data, dict) and "assets" in data:
                            # –°—Ç—Ä–æ–≥–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ: –ø—Ä–∏–π–º–∞—î–º–æ –ª–∏—à–µ —è–∫—â–æ seq –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ –∑—Ä–æ—Å—Ç–∞—î.
                            try:
                                meta_ts_raw = data.get("meta", {}).get("ts")
                                meta_seq = data.get("meta", {}).get("seq")
                                incoming_ts = None
                                if meta_ts_raw:
                                    incoming_ts = datetime.fromisoformat(
                                        str(meta_ts_raw).replace("Z", "+00:00")
                                    ).timestamp()
                                incoming_seq = None
                                try:
                                    if meta_seq is not None:
                                        incoming_seq = int(meta_seq)
                                except Exception:
                                    incoming_seq = None
                                if incoming_seq is not None and isinstance(
                                    self._last_seq, (int, float)
                                ):
                                    if incoming_seq == int(self._last_seq):
                                        ui_logger.debug(
                                            "Duplicate seq=%s ‚Äî skip", incoming_seq
                                        )
                                        continue
                                    if incoming_seq < int(self._last_seq):
                                        seq_backward = (
                                            int(self._last_seq) - incoming_seq
                                        )
                                        newer_ts = (
                                            incoming_ts is not None
                                            and incoming_ts
                                            >= self.last_update_time + 0.5
                                        )
                                        reset_window = (
                                            incoming_seq <= 5 and seq_backward > 20
                                        )
                                        if newer_ts or reset_window:
                                            ui_logger.warning(
                                                "Sequence reset detected: incoming_seq=%s last_seq=%s ts=%s ‚Äî accepting new epoch",
                                                incoming_seq,
                                                self._last_seq,
                                                meta_ts_raw,
                                            )
                                            self._last_seq = max(
                                                int(incoming_seq) - 1, -1
                                            )
                                        else:
                                            ui_logger.debug(
                                                "Stale seq=%s < last_seq=%s ‚Äî skip",
                                                incoming_seq,
                                                self._last_seq,
                                            )
                                            continue
                                    if incoming_seq > int(self._last_seq) + 1:
                                        # gap detected ‚Üí reload snapshot (–≤–æ–Ω–æ –º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏ –æ—Å—Ç–∞–Ω–Ω—å–æ–º—É publish)
                                        ui_logger.warning(
                                            "Gap detected: incoming_seq=%s last_seq=%s ‚Äî reload snapshot",
                                            incoming_seq,
                                            self._last_seq,
                                        )
                                        try:
                                            # –ü—Ä–∏ gap —Ç–∞–∫–æ–∂ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç–æ–π —Å–∞–º–∏–π –ø—ñ–¥—Ö—ñ–¥ primary‚Üífallback
                                            primary_snapshot = (
                                                REDIS_SNAPSHOT_UI_KEY
                                                if UI_USE_V2_NAMESPACE
                                                else REDIS_SNAPSHOT_KEY
                                            )
                                            fallback_snapshot = (
                                                REDIS_SNAPSHOT_KEY
                                                if UI_USE_V2_NAMESPACE
                                                else REDIS_SNAPSHOT_UI_KEY
                                            )
                                            snapshot_raw = await redis_client.get(
                                                primary_snapshot
                                            )
                                            if not snapshot_raw:
                                                snapshot_raw = await redis_client.get(
                                                    fallback_snapshot
                                                )
                                            if snapshot_raw:
                                                snap = json.loads(snapshot_raw)
                                                if isinstance(snap, dict):
                                                    self._last_results = (
                                                        snap.get("assets") or []
                                                    )
                                                    if self._last_results:
                                                        self._display_results = (
                                                            self._last_results
                                                        )
                                                    self._last_counters = (
                                                        snap.get("counters", {}) or {}
                                                    )
                                                    seq_val = snap.get("meta", {}).get(
                                                        "seq"
                                                    )
                                                    try:
                                                        if seq_val is not None:
                                                            self._last_seq = int(
                                                                seq_val
                                                            )
                                                    except Exception:
                                                        pass
                                                    ts_val = snap.get("meta", {}).get(
                                                        "ts"
                                                    )
                                                    if ts_val:
                                                        try:
                                                            self.last_update_time = (
                                                                datetime.fromisoformat(
                                                                    str(ts_val).replace(
                                                                        "Z", "+00:00"
                                                                    )
                                                                ).timestamp()
                                                            )
                                                        except Exception:
                                                            pass
                                                    ui_logger.info(
                                                        "Snapshot reloaded after gap: assets=%d seq=%s",
                                                        len(self._last_results),
                                                        self._last_seq,
                                                    )
                                        except Exception:
                                            ui_logger.debug(
                                                "Snapshot reload failed after gap",
                                                exc_info=True,
                                            )
                                        # –ø—ñ—Å–ª—è reload snapshot –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ –ø–æ—Ç–æ—á–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                                        continue
                                elif (
                                    incoming_ts is not None
                                    and incoming_ts < self.last_update_time
                                ):
                                    # –Ø–∫—â–æ seq –≤—ñ–¥—Å—É—Ç–Ω—ñ–π ‚Äî –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –∑–∞—Ö–∏—Å—Ç –∑–∞ —á–∞—Å–æ–º, —â–æ–± –Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –∑–∞—Å—Ç–∞—Ä—ñ–ª–µ
                                    ui_logger.debug(
                                        "Stale by time skipped: ts_in=%s < last_ts=%.3f",
                                        meta_ts_raw,
                                        self.last_update_time,
                                    )
                                    continue
                            except Exception:
                                pass
                            try:
                                assets_field = data.get("assets")
                                assets_len = (
                                    len(assets_field)
                                    if isinstance(assets_field, list)
                                    else None
                                )
                                ui_logger.debug(
                                    "UI recv keys=%s counters=%s assets_len=%s type=%s",
                                    list(data.keys()),
                                    data.get("counters"),
                                    assets_len,
                                    data.get("type"),
                                )
                                assets_dbg = data.get("assets")
                                if (
                                    isinstance(assets_dbg, list)
                                    and assets_dbg
                                    and isinstance(assets_dbg[0], dict)
                                ):
                                    ui_logger.debug(
                                        "UI first asset keys=%s",
                                        list(assets_dbg[0].keys()),
                                    )
                            except Exception:
                                pass
                            parsed_assets = data.get("assets") or []
                            # –Ø–∫—â–æ –ø—Ä–∏–π—à–æ–≤ –ø–æ—Ä–æ–∂–Ω—ñ–π —Å–ø–∏—Å–æ–∫, –∞–ª–µ –≤–∂–µ –º–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ
                            # –¥–∞–Ω—ñ ‚Äî —ñ–≥–Ω–æ—Ä—É—î–º–æ –æ—á–∏—â–µ–Ω–Ω—è
                            if not parsed_assets and self._display_results:
                                ui_logger.debug(
                                    "Ignore empty assets update; keeping %d cached rows",
                                    len(self._display_results),
                                )
                            else:
                                self._last_results = parsed_assets
                                if parsed_assets:
                                    self._display_results = parsed_assets
                            # meta.ts ‚Üí —á–∞—Å –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
                            meta_obj = data.get("meta", {}) or {}
                            meta_ts = meta_obj.get("ts")
                            meta_seq = meta_obj.get("seq")
                            if meta_ts:
                                try:
                                    incoming_ts = datetime.fromisoformat(
                                        str(meta_ts).replace("Z", "+00:00")
                                    ).timestamp()
                                    # –û–Ω–æ–≤–ª—é—î–º–æ –ª–∏—à–µ —è–∫—â–æ –Ω–æ–≤—ñ—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è (seq –∫–æ–Ω—Ç—Ä–æ–ª—å –≤–∏—â–µ)
                                    if incoming_ts >= self.last_update_time:
                                        self.last_update_time = incoming_ts
                                except Exception:
                                    pass
                            else:
                                # Heartbeat –±–µ–∑ meta.ts ‚Äî –æ–Ω–æ–≤–ª—é—î–º–æ —á–∞—Å –ª–∏—à–µ —è–∫—â–æ
                                # –¥–∞–≤–Ω–æ –Ω–µ –æ–Ω–æ–≤–ª—é–≤–∞–ª–æ—Å—å (>5s)
                                if time.time() - self.last_update_time > 5:
                                    self.last_update_time = time.time()
                            # –ó–∞–≤–µ—Ä—à–∞–ª—å–Ω–æ –æ–Ω–æ–≤–ª—é—î–º–æ last_seq, —è–∫—â–æ –ø—Ä–∏—Å—É—Ç–Ω—ñ–π
                            try:
                                if meta_seq is not None:
                                    self._last_seq = int(meta_seq)
                            except Exception:
                                pass
                            # counters ‚Üí –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫—É (–º–µ—Ä–¥–∂–∏–º–æ, —â–æ–± –Ω–µ –≥—É–±–∏—Ç–∏ core‚Äë–º–µ—Ç—Ä–∏–∫–∏)
                            incoming_counters = data.get("counters", {}) or {}
                            if isinstance(incoming_counters, dict):
                                self._last_counters.update(incoming_counters)
                            # –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –ª–æ–≥ —É–∑–≥–æ–¥–∂–µ–Ω–æ—Å—Ç—ñ
                            ui_logger.debug(
                                "Post-assign last_results_len=%d counters_assets=%s display_len=%d",
                                len(self._last_results),
                                self._last_counters.get("assets"),
                                len(self._display_results),
                            )
                        # (—Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å –∑—ñ —Å—Ç–∞—Ä–∏–º —Ñ–æ—Ä–º–∞—Ç–æ–º)
                        elif isinstance(data, list):
                            # Legacy format: whole message is just the assets list
                            if data:
                                self._last_results = data
                                self._display_results = data
                                self.last_update_time = time.time()
                            else:
                                ui_logger.debug(
                                    "Legacy empty list ignored; keeping cached results"
                                )

                    # –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –¥–ª—è –≤—Å—ñ—Ö ALERT*
                    for r in self._last_results:
                        sig = str(r.get("signal", "")).upper()
                        if sig.startswith("ALERT"):
                            self.alert_animator.add_alert(r.get("symbol", ""))

                    # –Ø–∫—â–æ counters –∫–∞–∂–µ >0, –∞ —Å–ø–∏—Å–æ–∫ –ø–æ—Ä–æ–∂–Ω—ñ–π ‚Äî –ª–æ–≥/–¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
                    # –í–∏–±—ñ—Ä —Å–ø–∏—Å–∫—É –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è: –∞–±–æ –ø–æ—Ç–æ—á–Ω–∏–π, –∞–±–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –Ω–µ–ø–æ—Ä–æ–∂–Ω—ñ–π
                    results_for_render = (
                        self._last_results
                        if self._last_results
                        else self._display_results
                    )
                    if (
                        not self._last_results
                        and self._last_counters.get("assets", 0) > 0
                        and self._display_results
                    ):
                        ui_logger.warning(
                            "Using cached results_for_render len=%d (last empty, "
                            "counters.assets=%s)",
                            len(self._display_results),
                            self._last_counters.get("assets"),
                        )
                    elif not results_for_render:
                        ui_logger.debug(
                            "Render with empty results_for_render; counters.assets=%s",
                            self._last_counters.get("assets"),
                        )
                    ui_logger.debug(
                        "Render: last=%d cached=%d render=%d last_update_age=%.1fs",
                        len(self._last_results),
                        len(self._display_results),
                        len(results_for_render),
                        time.time() - self.last_update_time,
                    )
                    table = self._build_signal_table(results_for_render)
                    live.update(table)
                    await asyncio.sleep(smooth_delay)

                except (ConnectionError, TimeoutError) as e:
                    ui_logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∑'—î–¥–Ω–∞–Ω–Ω—è: {e}")
                    await asyncio.sleep(3)
                    try:
                        await pubsub.reset()
                        # –ü–æ–≤—Ç–æ—Ä–Ω–æ –ø—ñ–¥–ø–∏—Å—É—î–º–æ—Å—è –Ω–∞ –≤–∂–µ –æ–±—Ä–∞–Ω–∏–π –∫–∞–Ω–∞–ª (–Ω–µ None)
                        await pubsub.subscribe(selected_channel)
                        ui_logger.info("‚úÖ –ü–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Redis")
                    except Exception as reconnect_err:
                        ui_logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: {reconnect_err}")
                except Exception as e:
                    ui_logger.error(f"–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
                    await asyncio.sleep(1)

    def _build_signal_table(
        self, results: list[dict[str, Any]], loading: bool = False
    ) -> Table:
        """–ü–æ–±—É–¥–æ–≤–∞ —Ç–∞–±–ª–∏—Ü—ñ –∑ —Å–∏–≥–Ω–∞–ª–∞–º–∏ —Ç–∞ –º–µ—Ç—Ä–∏–∫–∞–º–∏ —Å–∏—Å—Ç–µ–º–∏."""
        # –î—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–µ –ª–æ–≥—É–≤–∞–Ω–Ω—è –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ ¬´–∑–∞—Å—Ç–∏–≥–∞–Ω–Ω—è¬ª –∑–Ω–∞—á–µ–Ω—å
        try:
            if results:
                sample = results[0]
                ui_logger.debug(
                    "Render sample symbol=%s price_str=%s rsi=%s ts=%s seq=%s",
                    sample.get("symbol"),
                    sample.get("price_str"),
                    sample.get("rsi"),
                    (sample.get("stats") or {}).get("timestamp"),
                    (sample.get("meta") or {}).get("seq"),
                )
        except Exception:
            pass
        # counters –∑ payload—É, —è–∫—â–æ —î
        # –°–ø–µ—Ä—à—É –±–µ—Ä–µ–º–æ —Ñ–∞–∫—Ç–∏—á–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤ (—â–æ —Ä–µ–∞–ª—å–Ω–æ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è)
        total_assets = len(results)
        # ALERT –±–µ—Ä–µ–º–æ –∑ counters —è–∫—â–æ —î, —ñ–Ω–∞–∫—à–µ –ø–µ—Ä–µ—Ä–∞—Ö—É—î–º–æ –ª–æ–∫–∞–ª—å–Ω–æ
        alert_count = self._last_counters.get("alerts")
        if alert_count is None:
            alert_count = sum(
                1
                for r in results
                if str(r.get("signal", "")).upper().startswith("ALERT")
            )

        last_update = datetime.fromtimestamp(self.last_update_time).strftime("%H:%M:%S")

        # –ù–æ–≤—ñ —Ç—Ä–µ–π–¥-–º–µ—Ç—Ä–∏–∫–∏ –∑ core (—è–∫—â–æ –±—É–ª–∏ –ø—ñ–¥–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ)
        active_trades = self._last_counters.get("active_trades")
        closed_trades = self._last_counters.get("closed_trades")
        skipped = self._last_counters.get("skipped")
        skipped_ewma = self._last_counters.get("skipped_ewma")
        drift_ratio = self._last_counters.get("drift_ratio")
        dynamic_interval = self._last_counters.get("dynamic_interval")
        pressure = self._last_counters.get("pressure")
        pressure_norm = self._last_counters.get("pressure_norm")
        th_drift_high = self._last_counters.get("th_drift_high")
        th_drift_low = self._last_counters.get("th_drift_low")
        th_pressure = self._last_counters.get("th_pressure")
        consec_drift = self._last_counters.get("consec_drift_high")
        consec_pressure = self._last_counters.get("consec_pressure_high")
        alpha_val = self._last_counters.get("alpha")
        skip_reasons = self._last_counters.get("skip_reasons")

        # –§–æ—Ä–º–∞—Ç—É—î–º–æ drift (—è–∫—â–æ –±—É–¥–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç–∏—Å—è —á–µ—Ä–µ–∑ stats:core —É –º–∞–π–±—É—Ç–Ω—å–æ–º—É)
        if drift_ratio is not None:
            try:
                drift_val = float(drift_ratio)
                # –Ø–∫—â–æ thresholds –¥–æ—Å—Ç—É–ø–Ω—ñ ‚Äì –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—Ö
                if th_drift_high is not None and th_drift_low is not None:
                    if drift_val < float(th_drift_low):
                        drift_color = (
                            "yellow"  # –∑–∞–Ω–∞–¥—Ç–æ –ø–æ–≤—ñ–ª—å–Ω–æ / –º–∞–ª–æ —á–∞—Å—É? (–Ω–∏–∂–Ω—ñ–π –ø–æ—Ä—ñ–≥)
                        )
                    elif drift_val > float(th_drift_high):
                        drift_color = "red"
                    else:
                        drift_color = "green"
                else:
                    if drift_val < 0.9:
                        drift_color = "green"
                    elif drift_val <= 1.2:
                        drift_color = "yellow"
                    else:
                        drift_color = "red"
                drift_fragment = f" | Drift: [{drift_color}]{drift_val:.2f}[/]"
            except Exception:
                drift_fragment = ""
        else:
            drift_fragment = ""
            # –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä, —è–∫—â–æ –∫–ª—é—á —ñ—Å–Ω—É—î, –∞–ª–µ –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞—Ä–∞–∑—ñ –≤—ñ–¥—Å—É—Ç–Ω—î
            if "drift_ratio" in self._last_counters:
                drift_fragment = " | Drift: -"

        trades_fragment = ""
        if active_trades is not None or closed_trades is not None:
            trades_fragment = (
                f" | Trades: üü¢{active_trades or 0}/üî¥{closed_trades or 0}"
            )
        # –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è skipped / ewma
        if skipped is not None:
            skipped_fragment = f" | Skipped: {skipped}"
            if skipped_ewma is not None:
                try:
                    skipped_ewma_val = float(skipped_ewma)
                    color = (
                        "green"
                        if skipped_ewma_val < 1
                        else ("yellow" if skipped_ewma_val < 3 else "red")
                    )
                    skipped_fragment += f" (EWMA: [{color}]{skipped_ewma_val:.2f}[/])"
                except Exception:
                    pass
        else:
            skipped_fragment = ""
            if "skipped" in self._last_counters:
                skipped_fragment = " | Skipped: -"

        if dynamic_interval is not None:
            try:
                dyn_val = float(dynamic_interval)
                dyn_color = (
                    "green"
                    if dyn_val
                    <= 1.1 * (self._last_counters.get("cycle_interval") or dyn_val)
                    else (
                        "yellow"
                        if dyn_val
                        <= 2.0 * (self._last_counters.get("cycle_interval") or dyn_val)
                        else "red"
                    )
                )
                dynamic_fragment = f" | ŒîInterval: [{dyn_color}]{dyn_val:.1f}s[/]"
            except Exception:
                dynamic_fragment = f" | ŒîInterval: {dynamic_interval}"
        else:
            dynamic_fragment = ""
            if "dynamic_interval" in self._last_counters:
                dynamic_fragment = " | ŒîInterval: -"

        blink_fragment = ""
        if pressure is not None:
            try:
                p_val = float(pressure)
                if th_pressure is not None:
                    th_pressure_f = float(th_pressure)
                    if p_val > th_pressure_f:
                        p_color = "red"
                        self._pressure_alert_active = True
                    elif p_val > th_pressure_f * 0.7:
                        p_color = "yellow"
                        self._pressure_alert_active = False
                    else:
                        p_color = "green"
                        self._pressure_alert_active = False
                else:
                    p_color = (
                        "green" if p_val < 0.5 else ("yellow" if p_val < 1.5 else "red")
                    )
                    self._pressure_alert_active = p_color == "red"
                pressure_fragment = f" | Pressure: [{p_color}]{p_val:.2f}[/]"
                if pressure_norm is not None:
                    try:
                        pn = float(pressure_norm)
                        pressure_fragment += f"(n={pn:.2f})"
                    except Exception:
                        pass
                # –ú–∏–≥–æ—Ç—ñ–Ω–Ω—è
                if self._pressure_alert_active:
                    self._blink_state = not self._blink_state
                    if self._blink_state:
                        blink_fragment = " [blink][red]‚ö†[/][/blink]"
            except Exception:
                pressure_fragment = f" | Pressure: {pressure}"
        else:
            pressure_fragment = ""
            if "pressure" in self._last_counters:
                pressure_fragment = " | Pressure: -"

        consec_fragment = ""
        if (consec_drift or consec_pressure) and (consec_drift or 0) + (
            consec_pressure or 0
        ) > 0:
            consec_fragment = (
                f" | Seq(drift/press): {consec_drift or 0}/{consec_pressure or 0}"
            )
        alpha_fragment = (
            f" | Œ±={alpha_val:.2f}" if isinstance(alpha_val, (int, float)) else ""
        )
        if not alpha_fragment and "alpha" in self._last_counters:
            alpha_fragment = " | Œ±=-"
        skip_reasons_fragment = ""
        if isinstance(skip_reasons, dict) and skip_reasons:
            # take first 3 reasons for compact display
            top_pairs = list(skip_reasons.items())[:3]
            compact = ",".join(f"{k}:{v}" for k, v in top_pairs)
            skip_reasons_fragment = f" | SkipReasons[{compact}]"

        # –í–∏–¥–∞–ª–µ–Ω–æ: Stage2 (QDE) counters –∑ Redis (scenario/recommendation)
        # UI –±—ñ–ª—å—à–µ –Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—î —Ü—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏; –ª–æ–≥—ñ–∫—É –∑—ñ–±—Ä–∞–Ω–æ —É Publisher

        # Stage3 –±–ª–æ–∫—É–≤–∞–Ω–Ω—è –∑ counters —Å–Ω–∞–ø—à–æ—Ç—É (—è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω—ñ)
        blocks_fragment = ""
        try:
            # –ù–æ–≤—ñ –Ω–∞–∫–æ–ø–∏—á—É–≤–∞–ª—å–Ω—ñ –ª—ñ—á–∏–ª—å–Ω–∏–∫–∏
            b_lv = self._last_counters.get("blocked_alerts_lowvol") or 0
            b_htf = self._last_counters.get("blocked_alerts_htf") or 0
            b_lc = self._last_counters.get("blocked_alerts_lowconf") or 0
            passed = self._last_counters.get("passed_alerts") or 0
            downgraded = self._last_counters.get("downgraded_alerts") or 0
            gen = self._last_counters.get("generated_signals")
            skip = self._last_counters.get("skipped_signals")
            # Blocks: lowvol|htf|lowconf|OK (OK = passed)
            blocks_fragment = f" | Blocks: {b_lv}|{b_htf}|{b_lc}|{passed}"
            # –î–æ–¥–∞—î–º–æ Gen/Skip —è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω—ñ
            if isinstance(gen, int) or isinstance(skip, int):
                blocks_fragment += f" | Gen: {int(gen or 0)} | Skip: {int(skip or 0)}"
            # –ü–æ–∫–∞–∑–∞—Ç–∏ —Å–∫–∏–¥–∫–æ–≤—ñ –¥–∞—É–Ω–≥—Ä–µ–π–¥–∏ (—Å—É–º–∞) —è–∫—â–æ —î
            if downgraded:
                blocks_fragment += f" | Downgraded: {downgraded}"
        except Exception:
            pass

        # –Ü–Ω–¥–∏–∫–∞—Ç–æ—Ä–∏ Core/Health –ø–æ–≤–Ω—ñ—Å—Ç—é –ø—Ä–∏–±—Ä–∞–Ω—ñ –∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞

        title = (
            f"[bold]–°–∏—Å—Ç–µ–º–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É AiOne_t[/bold] | "
            f"–ê–∫—Ç–∏–≤–∏: [green]{total_assets}[/green] | "
            f"ALERT: [red]{alert_count}[/red] | "
            f"–û–Ω–æ–≤–ª–µ–Ω–æ: [cyan]{last_update}[/cyan]"
            f"{trades_fragment}{skipped_fragment}{drift_fragment}{dynamic_fragment}{pressure_fragment}{consec_fragment}{alpha_fragment}{blocks_fragment}{skip_reasons_fragment}{blink_fragment}"
        )

        table = Table(
            title=title,
            box=ROUNDED,
            show_header=True,
            header_style="bold magenta",
            expand=True,
        )

        columns = [
            ("–°–∏–º–≤–æ–ª", "left"),
            ("–¶—ñ–Ω–∞", "right"),
            ("–û–±–æ—Ä–æ—Ç USD", "right"),
            ("ATR%", "right"),
            ("RSI", "right"),
            ("–°—Ç–∞—Ç—É—Å", "center"),
            ("–ü—Ä–∏—á–∏–Ω–∏", "left"),
            ("–°–∏–≥–Ω–∞–ª", "center"),
            ("Band%", "right"),
            ("Conf%", "right"),
            ("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è", "left"),
            ("TP/SL", "right"),
        ]
        for header, justify in columns:
            j = (
                "left"
                if justify == "left"
                else "right" if justify == "right" else "center"
            )
            table.add_column(
                header,
                justify=cast(Literal["default", "left", "center", "right", "full"], j),
            )

        if loading or not results:
            # –ú–∞—Ä–∫–∞–ø Rich –º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏: –≤—ñ–¥–∫—Ä–∏–ª–∏ [cyan] ‚Äî –∑–∞–∫—Ä–∏–ª–∏ [/cyan]
            table.add_row(
                "[cyan]üîÑ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö...[/cyan]", *[""] * (len(columns) - 1)
            )
            return table

        def priority_key(r: dict) -> tuple:
            stats = r.get(K_STATS, {})
            reasons = set(r.get(K_TRIGGER_REASONS, []))
            is_alert = str(r.get(K_SIGNAL, "")).upper().startswith("ALERT")
            anomaly = (stats.get("volume_z", 0.0) or 0.0) >= self.vol_z_threshold
            warning = (not is_alert) and bool(reasons)
            # –í—Ä–∞—Ö–æ–≤—É—î–º–æ –Ω–æ–≤—ñ –∫–∞–Ω–æ–Ω—ñ—á–Ω—ñ —Ç–µ–≥–∏ bull/bear volume spike —è–∫ volume_spike
            has_vol_spike = (
                "volume_spike" in reasons
                or "bull_vol_spike" in reasons
                or "bear_vol_spike" in reasons
            )
            if is_alert and has_vol_spike:
                cat = 0
            elif is_alert:
                cat = 1
            elif anomaly:
                cat = 2
            elif warning:
                cat = 3
            else:
                cat = 4
            return (cat, -(stats.get("volume_mean", 0.0) or 0.0))

        try:
            sorted_results = sorted(results, key=priority_key)
        except Exception as e:
            ui_logger.debug("Sorting failed: %s", e)
            sorted_results = results

        for asset in sorted_results:
            # –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –Ω–µ–≤–∏–¥–∏–º–∏—Ö —Ä—è–¥–∫—ñ–≤
            try:
                if asset.get("visible") is False:
                    continue
            except Exception:
                pass
            symbol = str(asset.get(K_SYMBOL, "")).upper()
            stats = asset.get(K_STATS, {}) or {}

            # Render-only: –±–µ—Ä–µ–º–æ –ª–∏—à–µ –≥–æ—Ç–æ–≤–∏–π price_str (–±–µ–∑ –ª–æ–∫–∞–ª—å–Ω–∏—Ö —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—ñ–≤)
            price_str = (
                asset.get("price_str")
                if isinstance(asset.get("price_str"), str)
                else "-"
            )

            # Render-only: –±–µ—Ä–µ–º–æ –ª–∏—à–µ –≥–æ—Ç–æ–≤–∏–π volume_str
            volume_str = (
                asset.get("volume_str")
                if isinstance(asset.get("volume_str"), str)
                else "-"
            )
            volume_z = stats.get("volume_z", 0.0) or 0.0
            if volume_str != "-" and volume_z > self.vol_z_threshold:
                volume_str = f"[bold magenta]{volume_str}[/]"

            # Render-only: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ª–∏—à–µ –≥–æ—Ç–æ–≤–∏–π atr_pct
            atr_pct_val = asset.get("atr_pct")
            atr_pct = (
                float(atr_pct_val) if isinstance(atr_pct_val, (int, float)) else None
            )
            if atr_pct is None:
                atr_str = "-"
            else:
                atr_color = self._get_atr_color(float(atr_pct))
                atr_str = (
                    f"[{atr_color}]{float(atr_pct):.2f}%[/]"
                    if atr_color
                    else f"{float(atr_pct):.2f}%"
                )

            rsi_val = asset.get("rsi")
            rsi_f = float(rsi_val) if isinstance(rsi_val, (int, float)) else None
            if rsi_f is None:
                rsi_str = "-"
            else:
                rsi_color = self._get_rsi_color(float(rsi_f))
                if rsi_color:
                    rsi_str = f"[{rsi_color}]{float(rsi_f):.1f}[/]"
                else:
                    rsi_str = f"{float(rsi_f):.1f}"

            # Render-only: —Å—Ç–∞—Ç—É—Å –ª–∏—à–µ –∑ –≥–æ—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è
            status = asset.get("status") or "-"
            if status == "normal":
                status_icon = "üü¢"
            elif status == "init":
                status_icon = "üü®"
            else:
                status_icon = "üî¥"
            # –î–æ–¥–∞—î–º–æ –±–µ–π–¥–∂ HTF —è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω–æ
            htf_ok_val = asset.get("htf_ok")
            if isinstance(htf_ok_val, bool):
                htf_badge = " [dim](HTF‚úî)[/]" if htf_ok_val else " [red](HTF√ó)[/]"
            else:
                htf_badge = ""
            status_str = f"{status_icon} {status}{htf_badge}"

            signal = str(asset.get(K_SIGNAL, "NONE")).upper()
            signal_str = f"{self._get_signal_icon(signal)} {signal}"

            band_str = self._format_band_pct(asset)

            # –ù–æ–≤–∞ –∫–æ–ª–æ–Ω–∫–∞ –≤–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ (confidence)
            conf_val = asset.get("confidence")
            if not isinstance(conf_val, (int, float)):
                conf_val = 0.0
            conf_str = f"{float(conf_val)*100:.1f}%"

            # ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è –±–µ—Ä–µ—Ç—å—Å—è –∑ –∫–æ—Ä–µ–Ω—è, –∞ –Ω–µ –∑ stage2_result
            recommendation = str(asset.get("recommendation", "-"))
            rec_icon = self._get_recommendation_icon(recommendation)
            # –Ø–∫—â–æ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è BUY*, –∞–ª–µ htf_ok=False ‚Äî –ø—Ä–∏–≥–ª—É—à—É—î–º–æ
            if (
                recommendation in ("STRONG_BUY", "BUY_IN_DIPS")
                and asset.get("htf_ok") is False
            ):
                rec_str = f"[dim]{rec_icon} {recommendation}[/]"
            else:
                rec_str = f"{rec_icon} {recommendation}"

            # Render-only: TP/SL –ª–∏—à–µ –∑ –≥–æ—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è tp_sl
            tp_sl_str = asset.get("tp_sl") or "-"

            # –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –¥–ª—è ALERT*
            row_style = (
                "bold red"
                if signal.startswith("ALERT")
                and self.alert_animator.should_highlight(symbol)
                else ""
            )

            tags = []
            for reason in asset.get(K_TRIGGER_REASONS, []) or []:
                # –õ—é–¥–∏–Ω–æ–∑—Ä–æ–∑—É–º—ñ–ª—ñ —è—Ä–ª–∏–∫–∏ –¥–ª—è –Ω–æ–≤–∏—Ö —Ç–µ–≥—ñ–≤
                if reason in ("volume_spike", "bull_vol_spike", "bear_vol_spike"):
                    if reason == "bull_vol_spike":
                        tags.append("[magenta]–ë–∏—á–∏–π —Å–ø–ª–µ—Å–∫ –æ–±—Å—è–≥—É[/]")
                    elif reason == "bear_vol_spike":
                        tags.append("[magenta]–í–µ–¥–º–µ–∂–∏–π —Å–ø–ª–µ—Å–∫ –æ–±—Å—è–≥—É[/]")
                    else:
                        tags.append("[magenta]–°–ø–ª–µ—Å–∫ –æ–±—Å—è–≥—É[/]")
                else:
                    tags.append(f"[yellow]{reason}[/]")
            reasons = "  ".join(tags) or "-"

            table.add_row(
                symbol,
                price_str,
                volume_str,
                atr_str,
                rsi_str,
                status_str,
                reasons,
                signal_str,
                band_str,
                conf_str,
                rec_str,
                tp_sl_str,
                style=row_style,
            )

        return table


async def main() -> None:
    consumer = UIConsumer()
    await consumer.redis_consumer()


if __name__ == "__main__":
    asyncio.run(main())
