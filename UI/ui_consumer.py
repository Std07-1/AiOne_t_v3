# UI/ui_consumer.py
# -*- coding: utf-8 -*-
import os
import redis.asyncio as redis
import json
import logging
import asyncio
import time
from datetime import datetime
from typing import Any, Dict, List

from rich.console import Console
from rich.logging import RichHandler
from rich.live import Live
from rich.table import Table
from rich.box import ROUNDED

ui_console = Console(stderr=False)

ui_logger = logging.getLogger("ui_consumer")
ui_logger.setLevel(logging.INFO)
ui_logger.handlers.clear()
ui_logger.addHandler(RichHandler(console=Console(stderr=True), show_path=False))
ui_logger.propagate = False


class AlertAnimator:
    def __init__(self) -> None:
        self.active_alerts: Dict[str, float] = {}

    def add_alert(self, symbol: str) -> None:
        self.active_alerts[symbol] = time.time()

    def should_highlight(self, symbol: str) -> bool:
        ts = self.active_alerts.get(symbol)
        if ts is None:
            return False
        if (time.time() - ts) < 8.0:
            return True
        self.active_alerts.pop(symbol, None)
        return False


class UI_Consumer:
    def __init__(self, vol_z_threshold: float = 2.5, low_atr_threshold: float = 0.005):
        self.vol_z_threshold = vol_z_threshold
        self.low_atr_threshold = low_atr_threshold
        self.alert_animator = AlertAnimator()
        self.last_update_time: float = time.time()
        self._last_counters: Dict[str, Any] = {}
        self._display_results: List[Dict[str, Any]] = (
            []
        )  # –∫–µ—à –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –Ω–µ–ø–æ—Ä–æ–∂–Ω—å–æ–≥–æ —Å–ø–∏—Å–∫—É

    def _format_price(self, price: float) -> str:
        if price >= 1000:
            return f"{price:,.2f}"
        return f"{price:.4f}"

    def _get_rsi_color(self, rsi: float) -> str:
        if rsi < 30:
            return "green"
        if rsi < 50:
            return "light_green"
        if rsi < 70:
            return "yellow"
        return "red"

    def _get_atr_color(self, atr_pct: float) -> str:
        if atr_pct < self.low_atr_threshold:
            return "red"
        if atr_pct > 0.02:
            return "yellow"
        return ""

    def _get_signal_icon(self, signal: str) -> str:
        icons = {
            "ALERT": "üî¥",
            "NORMAL": "üü¢",
            "ALERT_BUY": "üü¢‚Üë",
            "ALERT_SELL": "üî¥‚Üì",
            "NONE": "‚ö™",
        }
        return icons.get(signal, "‚ùì")

    def _get_recommendation_icon(self, recommendation: str) -> str:
        icons = {
            "STRONG_BUY": "üü¢‚Üë‚Üë",
            "BUY_IN_DIPS": "üü¢‚Üë",
            "HOLD": "üü°",
            "SELL_ON_RALLIES": "üî¥‚Üì",
            "STRONG_SELL": "üî¥‚Üì‚Üì",
            "AVOID": "‚ö´",
            "WAIT": "‚ö™",
        }
        return icons.get(recommendation, "")

    async def redis_consumer(
        self,
        redis_url: str = None,
        channel: str = "asset_state_update",
        refresh_rate: float = 0.8,
        loading_delay: float = 1.5,
        smooth_delay: float = 0.05,
    ) -> None:
        """
        –°–ª—É—Ö–∞—î –∫–∞–Ω–∞–ª Redis Pub/Sub, –ø—Ä–∏–π–º–∞—î payload {"meta","counters","assets"} —ñ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–∞–±–ª–∏—Ü—é.
        """
        # –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –∫–æ–Ω—Ñ—ñ–≥—ñ–≤ –∑ ENV, —â–æ–± –Ω–µ –ø—Ä–æ–º–∞—Ö–Ω—É—Ç–∏—Å—å –ø–æ —ñ–Ω—Å—Ç–∞–Ω—Å—É Redis
        redis_url = (
            redis_url
            or os.getenv("REDIS_URL")
            or f"redis://{os.getenv('REDIS_HOST','localhost')}:{os.getenv('REDIS_PORT','6379')}/0"
        )

        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ–≥–æ —Å–ø–∏—Å–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ (instance-level)
        if not hasattr(self, "_last_results"):
            self._last_results = []  # type: ignore[attr-defined]

        redis_client = redis.from_url(
            redis_url, decode_responses=True, encoding="utf-8"
        )
        pubsub = redis_client.pubsub()

        # –°–ø—Ä–æ–±–∞ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç—É –ø–µ—Ä–µ–¥ –ø—ñ–¥–ø–∏—Å–∫–æ—é
        try:
            snapshot_raw = await redis_client.get("asset_state_snapshot")
            if snapshot_raw:
                snap = json.loads(snapshot_raw)
                if isinstance(snap, dict) and isinstance(snap.get("assets"), list):
                    self._last_results = snap.get("assets") or []
                    if self._last_results:
                        self._display_results = self._last_results
                    self._last_counters = snap.get("counters", {}) or {}
                    meta_ts = snap.get("meta", {}).get("ts")
                    if meta_ts:
                        try:
                            self.last_update_time = datetime.fromisoformat(
                                meta_ts.replace("Z", "")
                            ).timestamp()
                        except Exception:
                            pass
                    ui_logger.info(
                        "üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç: %d –∞–∫—Ç–∏–≤—ñ–≤",
                        len(self._last_results),
                    )
        except Exception:
            ui_logger.debug("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç", exc_info=True)

        await asyncio.sleep(loading_delay)
        await pubsub.subscribe(channel)
        ui_logger.info(f"üîó –ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Redis ({redis_url}), –∫–∞–Ω–∞–ª '{channel}'...")

        # –ü–æ—á–∞—Ç–∫–æ–≤–µ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è: —è–∫—â–æ –≤–∂–µ —î —Å–Ω–∞–ø—à–æ—Ç, –ø–æ–∫–∞–∑—É—î–º–æ –π–æ–≥–æ –æ–¥—Ä–∞–∑—É
        initial_results = self._display_results if self._display_results else []
        with Live(
            self._build_signal_table(
                initial_results, loading=not bool(initial_results)
            ),
            console=ui_console,
            refresh_per_second=refresh_rate,
            screen=False,
            transient=False,
        ) as live:
            while True:
                try:
                    # –ü–µ—Ä—ñ–æ–¥–∏—á–Ω–∏–π fallback: —è–∫—â–æ >7s –±–µ–∑ –æ–Ω–æ–≤–ª–µ–Ω—å —ñ –º–∞—î–º–æ –ø–æ—Ä–æ–∂–Ω—ñ–π live —Å–ø–∏—Å–æ–∫, –ø—Ä–æ–±—É—î–º–æ –ø–µ—Ä–µ–∑—á–∏—Ç–∞—Ç–∏ —Å–Ω–∞–ø—à–æ—Ç
                    if (
                        (time.time() - self.last_update_time) > 7
                        and not self._last_results
                        and self._display_results
                    ):
                        try:
                            snapshot_raw = await redis_client.get(
                                "asset_state_snapshot"
                            )
                            if snapshot_raw:
                                snap = json.loads(snapshot_raw)
                                assets_snap = (
                                    snap.get("assets")
                                    if isinstance(snap, dict)
                                    else None
                                )
                                if isinstance(assets_snap, list) and assets_snap:
                                    self._display_results = assets_snap
                                    ui_logger.info(
                                        "‚ôªÔ∏è Fallback snapshot reload: %d –∞–∫—Ç–∏–≤—ñ–≤",
                                        len(assets_snap),
                                    )
                        except Exception:  # broad except: fallback reload best-effort
                            pass
                    message = await pubsub.get_message(
                        ignore_subscribe_messages=True, timeout=1.0
                    )
                    if message:
                        try:
                            data = json.loads(message["data"])
                        except Exception:
                            ui_logger.error(
                                "–ù–µ–≤–¥–∞—á–∞ json.loads –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"
                            )
                            data = None

                        # ‚úÖ –ù–æ–≤–∏–π –∫–æ—Ä–µ–∫—Ç–Ω–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ–¥—é—Å–µ—Ä–∞: –æ—á—ñ–∫—É—î–º–æ dict –∑ 'assets'
                        if isinstance(data, dict) and "assets" in data:
                            try:
                                ui_logger.debug(
                                    "UI recv keys=%s counters=%s assets_len=%s type=%s",
                                    list(data.keys()),
                                    data.get("counters"),
                                    (
                                        None
                                        if data.get("assets") is None
                                        else len(data.get("assets"))
                                    ),
                                    data.get("type"),
                                )
                                if data.get("assets"):
                                    ui_logger.debug(
                                        "UI first asset keys=%s",
                                        list(data.get("assets")[0].keys()),
                                    )
                            except Exception:
                                pass
                            parsed_assets = data.get("assets") or []
                            # –Ø–∫—â–æ –ø—Ä–∏–π—à–æ–≤ –ø–æ—Ä–æ–∂–Ω—ñ–π —Å–ø–∏—Å–æ–∫, –∞–ª–µ –º–∏ –≤–∂–µ –º–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –¥–∞–Ω—ñ ‚Äì —ñ–≥–Ω–æ—Ä—É—î–º–æ –æ—á–∏—â–µ–Ω–Ω—è
                            if not parsed_assets and self._display_results:
                                ui_logger.debug(
                                    "Ignore empty assets update; keeping %d cached rows",
                                    len(self._display_results),
                                )
                            else:
                                self._last_results = parsed_assets
                                if parsed_assets:
                                    self._display_results = parsed_assets
                            # meta.ts ‚Üí —á–∞—Å –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
                            meta_ts = data.get("meta", {}).get("ts")
                            if meta_ts:
                                try:
                                    incoming_ts = datetime.fromisoformat(
                                        meta_ts.replace("Z", "")
                                    ).timestamp()
                                    # –û–Ω–æ–≤–ª—é—î–º–æ –ª–∏—à–µ —è–∫—â–æ –Ω–æ–≤—ñ—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è
                                    if incoming_ts >= self.last_update_time:
                                        self.last_update_time = incoming_ts
                                except Exception:
                                    pass
                            else:
                                # Heartbeat –±–µ–∑ meta.ts ‚Äì –æ–Ω–æ–≤–ª—é—î–º–æ —á–∞—Å –ª–∏—à–µ —è–∫—â–æ –¥–∞–≤–Ω–æ –Ω–µ –æ–Ω–æ–≤–ª—é–≤–∞–ª–æ—Å—å (>5s)
                                if time.time() - self.last_update_time > 5:
                                    self.last_update_time = time.time()
                            # counters ‚Üí –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫—É
                            self._last_counters = data.get("counters", {}) or {}
                            # –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –ª–æ–≥ —É–∑–≥–æ–¥–∂–µ–Ω–æ—Å—Ç—ñ
                            ui_logger.debug(
                                "Post-assign last_results_len=%d counters_assets=%s display_len=%d",
                                len(self._last_results),
                                self._last_counters.get("assets"),
                                len(self._display_results),
                            )
                        # (—Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å –∑—ñ —Å—Ç–∞—Ä–∏–º —Ñ–æ—Ä–º–∞—Ç–æ–º)
                        elif isinstance(data, list):
                            # Legacy format: whole message is just the assets list
                            if data:
                                self._last_results = data
                                self._display_results = data
                                self.last_update_time = time.time()
                            else:
                                ui_logger.debug(
                                    "Legacy empty list ignored; keeping cached results"
                                )

                    # –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –¥–ª—è –≤—Å—ñ—Ö ALERT*
                    for r in self._last_results:
                        sig = str(r.get("signal", "")).upper()
                        if sig.startswith("ALERT"):
                            self.alert_animator.add_alert(r.get("symbol", ""))

                    # –Ø–∫—â–æ counters –∫–∞–∂–µ >0, –∞ —Å–ø–∏—Å–æ–∫ –ø–æ—Ä–æ–∂–Ω—ñ–π ‚Äî –ª–æ–≥/–¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
                    # –í–∏–±—ñ—Ä —Å–ø–∏—Å–∫—É –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è: –∞–±–æ –ø–æ—Ç–æ—á–Ω–∏–π, –∞–±–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –Ω–µ–ø–æ—Ä–æ–∂–Ω—ñ–π
                    results_for_render = (
                        self._last_results
                        if self._last_results
                        else self._display_results
                    )
                    if (
                        not self._last_results
                        and self._last_counters.get("assets", 0) > 0
                        and self._display_results
                    ):
                        ui_logger.warning(
                            "Using cached results_for_render len=%d (last empty, counters.assets=%s)",
                            len(self._display_results),
                            self._last_counters.get("assets"),
                        )
                    elif not results_for_render:
                        ui_logger.debug(
                            "Render with empty results_for_render; counters.assets=%s",
                            self._last_counters.get("assets"),
                        )
                    ui_logger.debug(
                        "Render: last=%d cached=%d render=%d last_update_age=%.1fs",
                        len(self._last_results),
                        len(self._display_results),
                        len(results_for_render),
                        time.time() - self.last_update_time,
                    )
                    table = self._build_signal_table(results_for_render)
                    live.update(table)
                    await asyncio.sleep(smooth_delay)

                except (ConnectionError, TimeoutError) as e:
                    ui_logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∑'—î–¥–Ω–∞–Ω–Ω—è: {e}")
                    await asyncio.sleep(3)
                    try:
                        await pubsub.reset()
                        await pubsub.subscribe(channel)
                        ui_logger.info("‚úÖ –ü–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Redis")
                    except Exception as reconnect_err:
                        ui_logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: {reconnect_err}")
                except Exception as e:
                    ui_logger.error(f"–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
                    await asyncio.sleep(1)

    def _build_signal_table(self, results: List[dict], loading: bool = False) -> Table:
        """–ü–æ–±—É–¥–æ–≤–∞ —Ç–∞–±–ª–∏—Ü—ñ –∑ —Å–∏–≥–Ω–∞–ª–∞–º–∏ —Ç–∞ –º–µ—Ç—Ä–∏–∫–∞–º–∏ —Å–∏—Å—Ç–µ–º–∏."""
        # counters –∑ payload—É, —è–∫—â–æ —î
        # –°–ø–µ—Ä—à—É –±–µ—Ä–µ–º–æ —Ñ–∞–∫—Ç–∏—á–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤ (—â–æ —Ä–µ–∞–ª—å–Ω–æ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è)
        total_assets = len(results)
        # ALERT –±–µ—Ä–µ–º–æ –∑ counters —è–∫—â–æ —î, —ñ–Ω–∞–∫—à–µ –ø–µ—Ä–µ—Ä–∞—Ö—É—î–º–æ –ª–æ–∫–∞–ª—å–Ω–æ
        alert_count = self._last_counters.get("alerts")
        if alert_count is None:
            alert_count = sum(
                1
                for r in results
                if str(r.get("signal", "")).upper().startswith("ALERT")
            )

        last_update = datetime.fromtimestamp(self.last_update_time).strftime("%H:%M:%S")

        title = (
            f"[bold]–°–∏—Å—Ç–µ–º–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É AiOne_t[/bold] | "
            f"–ê–∫—Ç–∏–≤–∏: [green]{total_assets}[/green] | "
            f"ALERT: [red]{alert_count}[/red] | "
            f"–û–Ω–æ–≤–ª–µ–Ω–æ: [cyan]{last_update}[/cyan]"
        )

        table = Table(
            title=title,
            box=ROUNDED,
            show_header=True,
            header_style="bold magenta",
            expand=True,
        )

        columns = [
            ("–°–∏–º–≤–æ–ª", "left"),
            ("–¶—ñ–Ω–∞", "right"),
            ("–û–±–æ—Ä–æ—Ç USD", "right"),
            ("ATR%", "right"),
            ("RSI", "right"),
            ("–°—Ç–∞—Ç—É—Å", "center"),
            ("–ü—Ä–∏—á–∏–Ω–∏", "left"),
            ("–°–∏–≥–Ω–∞–ª", "center"),
            ("Conf%", "right"),
            ("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è", "left"),
            ("TP/SL", "right"),
        ]
        for header, justify in columns:
            table.add_column(header, justify=justify)

        if loading or not results:
            # –ú–∞—Ä–∫–∞–ø Rich –º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏: –≤—ñ–¥–∫—Ä–∏–ª–∏ [cyan] ‚Äî –∑–∞–∫—Ä–∏–ª–∏ [/cyan]
            table.add_row(
                "[cyan]üîÑ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö...[/cyan]", *[""] * (len(columns) - 1)
            )
            return table

        def priority_key(r: dict) -> tuple:
            stats = r.get("stats", {})
            reasons = set(r.get("trigger_reasons", []))
            is_alert = str(r.get("signal", "")).upper().startswith("ALERT")
            anomaly = (stats.get("volume_z", 0.0) or 0.0) >= self.vol_z_threshold
            warning = (not is_alert) and bool(reasons)
            if is_alert and "volume_spike" in reasons:
                cat = 0
            elif is_alert:
                cat = 1
            elif anomaly:
                cat = 2
            elif warning:
                cat = 3
            else:
                cat = 4
            return (cat, -(stats.get("volume_mean", 0.0) or 0.0))

        try:
            sorted_results = sorted(results, key=priority_key)
        except Exception as e:
            ui_logger.debug("Sorting failed: %s", e)
            sorted_results = results

        for asset in sorted_results:
            symbol = str(asset.get("symbol", "")).upper()
            stats = asset.get("stats", {}) or {}

            # –ü–µ—Ä–µ–≤–∞–≥–∞ –ø–ª–æ—Å–∫–∏—Ö –∫–ª—é—á—ñ–≤ —è–∫—â–æ –≤–æ–Ω–∏ –≤–∂–µ —Ä–æ–∑—Ä–∞—Ö–æ–≤–∞–Ω—ñ –ø—Ä–æ–¥—é—Å–µ—Ä–æ–º
            if "price_str" in asset and isinstance(asset.get("price_str"), str):
                price_str = asset["price_str"]
                current_price = float(
                    asset.get("price", stats.get("current_price", 0.0)) or 0.0
                )
            else:
                if "price" in asset and isinstance(asset.get("price"), (int, float)):
                    current_price = float(asset.get("price") or 0.0)
                else:
                    current_price = stats.get("current_price", 0.0) or 0.0
                price_str = self._format_price(float(current_price))

            volume = asset.get("volume")
            if not isinstance(volume, (int, float)):
                volume = stats.get("volume_mean", 0.0) or 0.0
            volume_z = stats.get("volume_z", 0.0) or 0.0
            if "volume_str" in asset and isinstance(asset.get("volume_str"), str):
                volume_str = asset["volume_str"]
            else:
                volume_str = f"{volume:,.0f}"
            if volume_z > self.vol_z_threshold:
                volume_str = f"[bold magenta]{volume_str}[/]"

            if "atr_pct" in asset and isinstance(asset.get("atr_pct"), (int, float)):
                atr_pct = float(asset.get("atr_pct") or 0.0)
            else:
                atr = stats.get("atr", 0.0) or 0.0
                atr_pct = (
                    (float(atr) / float(current_price) * 100.0)
                    if current_price
                    else 0.0
                )
            atr_color = self._get_atr_color(atr_pct)
            if atr_color:
                atr_str = f"[{atr_color}]{atr_pct:.2f}%[/]"
            else:
                atr_str = f"{atr_pct:.2f}%"

            rsi_val = asset.get("rsi")
            if not isinstance(rsi_val, (int, float)):
                rsi_val = stats.get("rsi", 0.0) or 0.0
            rsi_color = self._get_rsi_color(float(rsi_val))
            if rsi_color:
                rsi_str = f"[{rsi_color}]{float(rsi_val):.1f}[/]"
            else:
                rsi_str = f"{float(rsi_val):.1f}"

            status = asset.get("status") or asset.get("state", "normal")
            if status == "normal":
                status_icon = "üü¢"
            elif status == "init":
                status_icon = "üü®"
            else:
                status_icon = "üî¥"
            status_str = f"{status_icon} {status}"

            signal = str(asset.get("signal", "NONE")).upper()
            signal_str = f"{self._get_signal_icon(signal)} {signal}"

            # –ù–æ–≤–∞ –∫–æ–ª–æ–Ω–∫–∞ –≤–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ (confidence)
            conf_val = asset.get("confidence")
            if not isinstance(conf_val, (int, float)):
                conf_val = 0.0
            conf_str = f"{float(conf_val)*100:.1f}%"

            # ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è –±–µ—Ä–µ—Ç—å—Å—è –∑ –∫–æ—Ä–µ–Ω—è, –∞ –Ω–µ –∑ stage2_result
            recommendation = str(asset.get("recommendation", "-"))
            rec_str = (
                f"{self._get_recommendation_icon(recommendation)} {recommendation}"
            )

            if "tp_sl" in asset:
                tp_sl_str = asset.get("tp_sl") or "-"
            else:
                tp = asset.get("tp")
                sl = asset.get("sl")
                tp_sl_str = (
                    f"TP: {self._format_price(tp)}\nSL: {self._format_price(sl)}"
                    if tp and sl
                    else "-"
                )

            # –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –¥–ª—è ALERT*
            row_style = (
                "bold red"
                if signal.startswith("ALERT")
                and self.alert_animator.should_highlight(symbol)
                else ""
            )

            tags = []
            for reason in asset.get("trigger_reasons", []) or []:
                tags.append(
                    "[magenta]–°–ø–ª–µ—Å–∫ –æ–±—Å—è–≥—É[/]"
                    if reason == "volume_spike"
                    else f"[yellow]{reason}[/]"
                )
            reasons = "  ".join(tags) or "-"

            table.add_row(
                symbol,
                price_str,
                volume_str,
                atr_str,
                rsi_str,
                status_str,
                reasons,
                signal_str,
                conf_str,
                rec_str,
                tp_sl_str,
                style=row_style,
            )

        return table


async def main() -> None:
    consumer = UI_Consumer()
    await consumer.redis_consumer()


if __name__ == "__main__":
    asyncio.run(main())
