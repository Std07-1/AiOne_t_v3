import asyncio
import json
import logging
import os
import time
from datetime import datetime
from typing import Any, Literal, cast

import redis.asyncio as redis
from rich.box import ROUNDED
from rich.console import Console
from rich.live import Live
from rich.logging import RichHandler
from rich.table import Table

from config.config import (
    K_SIGNAL,
    K_STATS,
    K_SYMBOL,
    K_TRIGGER_REASONS,
    REDIS_CHANNEL_ASSET_STATE,
    REDIS_SNAPSHOT_KEY,
    STATS_CORE_KEY,
)
from utils.utils import format_price

ui_console = Console(stderr=False)

ui_logger = logging.getLogger("ui_consumer")
ui_logger.setLevel(logging.INFO)
ui_logger.handlers.clear()
ui_logger.addHandler(RichHandler(console=Console(stderr=True), show_path=False))
ui_logger.propagate = False


class AlertAnimator:
    def __init__(self) -> None:
        self.active_alerts: dict[str, float] = {}

    def add_alert(self, symbol: str) -> None:
        self.active_alerts[symbol] = time.time()

    def should_highlight(self, symbol: str) -> bool:
        ts = self.active_alerts.get(symbol)
        if ts is None:
            return False
        if (time.time() - ts) < 8.0:
            return True
        self.active_alerts.pop(symbol, None)
        return False


class UIConsumer:
    def __init__(self, vol_z_threshold: float = 2.5, low_atr_threshold: float = 0.005):
        self.vol_z_threshold = vol_z_threshold
        self.low_atr_threshold = low_atr_threshold
        self.alert_animator = AlertAnimator()
        self.last_update_time: float = time.time()
        self._last_counters: dict[str, Any] = {}
        self._display_results: list[dict[str, Any]] = (
            []
        )  # –∫–µ—à –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –Ω–µ–ø–æ—Ä–æ–∂–Ω—å–æ–≥–æ —Å–ø–∏—Å–∫—É
        self._blink_state = False  # –¥–ª—è –º–∏–≥–æ—Ç—ñ–Ω–Ω—è pressure
        self._pressure_alert_active = False

    def _format_price(self, price: float | None, symbol: str) -> str:
        """–§–æ—Ä–º–∞—Ç—É—î —Ü—ñ–Ω—É –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —É —Ç–∞–±–ª–∏—Ü—ñ.

        –Ø–∫—â–æ –∑–Ω–∞—á–µ–Ω–Ω—è –≤—ñ–¥—Å—É—Ç–Ω—î –∞–±–æ –Ω–µ–ø–æ–∑–∏—Ç–∏–≤–Ω–µ ‚Äî –ø–æ–≤–µ—Ä—Ç–∞—î "-";
        —ñ–Ω–∞–∫—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î utils.format_price.
        """
        try:
            if price is None:
                return "-"
            p = float(price)
            if p <= 0:
                return "-"
            return format_price(p, symbol)
        except Exception:
            return "-"

    def _get_rsi_color(self, rsi: float) -> str:
        if rsi < 30:
            return "green"
        if rsi < 50:
            return "light_green"
        if rsi < 70:
            return "yellow"
        return "red"

    def _get_atr_color(self, atr_pct: float) -> str:
        if atr_pct < self.low_atr_threshold:
            return "red"
        if atr_pct > 0.02:
            return "yellow"
        return ""

    def _get_signal_icon(self, signal: str) -> str:
        icons = {
            "ALERT": "üî¥",
            "NORMAL": "üü¢",
            "ALERT_BUY": "üü¢‚Üë",
            "ALERT_SELL": "üî¥‚Üì",
            "NONE": "‚ö™",
        }
        return icons.get(signal, "‚ùì")

    def _get_recommendation_icon(self, recommendation: str) -> str:
        icons = {
            "STRONG_BUY": "üü¢‚Üë‚Üë",
            "BUY_IN_DIPS": "üü¢‚Üë",
            "HOLD": "üü°",
            "SELL_ON_RALLIES": "üî¥‚Üì",
            "STRONG_SELL": "üî¥‚Üì‚Üì",
            "AVOID": "‚ö´",
            "WAIT": "‚ö™",
        }
        return icons.get(recommendation, "")

    async def redis_consumer(
        self,
        redis_url: str | None = None,
        channel: str = REDIS_CHANNEL_ASSET_STATE,
        refresh_rate: float = 0.8,
        loading_delay: float = 1.5,
        smooth_delay: float = 0.05,
    ) -> None:
        """
        –°–ª—É—Ö–∞—î –∫–∞–Ω–∞–ª Redis Pub/Sub, –ø—Ä–∏–π–º–∞—î payload {"meta","counters","assets"}
        —ñ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–∞–±–ª–∏—Ü—é.
        """
        # –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –∫–æ–Ω—Ñ—ñ–≥—ñ–≤ –∑ ENV, —â–æ–± –Ω–µ –ø—Ä–æ–º–∞—Ö–Ω—É—Ç–∏—Å—å –ø–æ —ñ–Ω—Å—Ç–∞–Ω—Å—É Redis
        redis_url = (
            redis_url
            or os.getenv("REDIS_URL")
            or f"redis://{os.getenv('REDIS_HOST','localhost')}:{os.getenv('REDIS_PORT','6379')}/0"
        )

        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ–≥–æ —Å–ø–∏—Å–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ (instance-level) –∑ —Ç–∏–ø–æ–º
        if not hasattr(self, "_last_results"):
            self._last_results: list[dict[str, Any]] = []

        redis_client = redis.from_url(
            redis_url, decode_responses=True, encoding="utf-8"
        )
        pubsub = redis_client.pubsub()

        # –°–ø—Ä–æ–±–∞ –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç—É –ø–µ—Ä–µ–¥ –ø—ñ–¥–ø–∏—Å–∫–æ—é + –Ω–æ–≤—ñ core-—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        try:
            snapshot_raw = await redis_client.get(REDIS_SNAPSHOT_KEY)
            if snapshot_raw:
                snap = json.loads(snapshot_raw)
                if isinstance(snap, dict) and isinstance(snap.get("assets"), list):
                    self._last_results = snap.get("assets") or []
                    if self._last_results:
                        self._display_results = self._last_results
                    self._last_counters = snap.get("counters", {}) or {}
                    meta_ts = snap.get("meta", {}).get("ts")
                    if meta_ts:
                        try:
                            self.last_update_time = datetime.fromisoformat(
                                meta_ts.replace("Z", "")
                            ).timestamp()
                        except Exception:
                            pass
                    ui_logger.info(
                        "üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç: %d –∞–∫—Ç–∏–≤—ñ–≤",
                        len(self._last_results),
                    )
            # –ù–æ–≤—ñ –∞–≥—Ä–µ–≥–æ–≤–∞–Ω—ñ —Ç—Ä–µ–π–¥-–º–µ—Ç—Ä–∏–∫–∏ (stats:core)
            try:
                core_raw = await redis_client.get(STATS_CORE_KEY)
                if core_raw:
                    core = json.loads(core_raw)
                    if not isinstance(core, dict):
                        core = {}
                    trades_part = core.get("trades", {})
                    # –∫–µ—à—É—î–º–æ —è–∫ counters.* –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫—É
                    if trades_part:
                        self._last_counters.update(
                            {
                                "active_trades": trades_part.get("active"),
                                "closed_trades": trades_part.get("closed"),
                                "skipped": core.get("skipped"),
                                "skipped_ewma": core.get("skipped_ewma"),
                                "drift_ratio": core.get("drift_ratio"),
                                "dynamic_interval": core.get("dynamic_interval"),
                                "pressure": core.get("pressure"),
                                "pressure_norm": core.get("pressure_norm"),
                                "alpha": core.get("alpha"),
                            }
                        )
                        thresholds = core.get("thresholds") or {}
                        consecutive = core.get("consecutive") or {}
                        self._last_counters["th_drift_high"] = thresholds.get(
                            "drift_high"
                        )
                        self._last_counters["th_drift_low"] = thresholds.get(
                            "drift_low"
                        )
                        self._last_counters["th_pressure"] = thresholds.get("pressure")
                        self._last_counters["consec_drift_high"] = consecutive.get(
                            "drift_high"
                        )
                        self._last_counters["consec_pressure_high"] = consecutive.get(
                            "pressure_high"
                        )
                        if "skip_reasons" in core and isinstance(
                            core.get("skip_reasons"), dict
                        ):
                            self._last_counters["skip_reasons"] = core.get(
                                "skip_reasons"
                            )
                        # last_update_ts –º–æ–∂–Ω–∞ –≤—ñ–¥–æ–±—Ä–∞–∑–∏—Ç–∏ —è–∫ heartbeat
                        if core.get("last_update_ts"):
                            self.last_update_time = float(core["last_update_ts"])
            except Exception:
                pass
        except Exception:  # broad-except: –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∏–π
            ui_logger.debug("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–Ω–∞–ø—à–æ—Ç", exc_info=True)

        await asyncio.sleep(loading_delay)
        await pubsub.subscribe(channel)
        ui_logger.info(f"üîó –ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Redis ({redis_url}), –∫–∞–Ω–∞–ª '{channel}'...")

        # –ü–æ—á–∞—Ç–∫–æ–≤–µ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è: —è–∫—â–æ –≤–∂–µ —î —Å–Ω–∞–ø—à–æ—Ç, –ø–æ–∫–∞–∑—É—î–º–æ –π–æ–≥–æ –æ–¥—Ä–∞–∑—É
        initial_results = self._display_results if self._display_results else []
        with Live(
            self._build_signal_table(
                initial_results, loading=not bool(initial_results)
            ),
            console=ui_console,
            refresh_per_second=refresh_rate,
            screen=False,
            transient=False,
        ) as live:
            while True:
                try:
                    # –ü–µ—Ä—ñ–æ–¥–∏—á–Ω–∏–π fallback: —è–∫—â–æ >7s –±–µ–∑ –æ–Ω–æ–≤–ª–µ–Ω—å —ñ –º–∞—î–º–æ –ø–æ—Ä–æ–∂–Ω—ñ–π
                    # live —Å–ø–∏—Å–æ–∫, –ø—Ä–æ–±—É—î–º–æ –ø–µ—Ä–µ–∑—á–∏—Ç–∞—Ç–∏ —Å–Ω–∞–ø—à–æ—Ç
                    if (
                        (time.time() - self.last_update_time) > 7
                        and not self._last_results
                        and self._display_results
                    ):
                        try:
                            snapshot_raw = await redis_client.get(REDIS_SNAPSHOT_KEY)
                            if snapshot_raw:
                                snap = json.loads(snapshot_raw)
                                assets_snap = (
                                    snap.get("assets")
                                    if isinstance(snap, dict)
                                    else None
                                )
                                if isinstance(assets_snap, list) and assets_snap:
                                    self._display_results = assets_snap
                                    ui_logger.info(
                                        "‚ôªÔ∏è Fallback snapshot reload: %d –∞–∫—Ç–∏–≤—ñ–≤",
                                        len(assets_snap),
                                    )
                        except Exception:  # broad except: fallback reload best-effort
                            pass
                    message = await pubsub.get_message(
                        ignore_subscribe_messages=True, timeout=1.0
                    )
                    if message:
                        try:
                            data = json.loads(message["data"])
                        except Exception:
                            ui_logger.error(
                                "–ù–µ–≤–¥–∞—á–∞ json.loads –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"
                            )
                            data = None

                        # ‚úÖ –ù–æ–≤–∏–π –∫–æ—Ä–µ–∫—Ç–Ω–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ–¥—é—Å–µ—Ä–∞: –æ—á—ñ–∫—É—î–º–æ dict –∑ 'assets'
                        if isinstance(data, dict) and "assets" in data:
                            try:
                                assets_field = data.get("assets")
                                assets_len = (
                                    len(assets_field)
                                    if isinstance(assets_field, list)
                                    else None
                                )
                                ui_logger.debug(
                                    "UI recv keys=%s counters=%s assets_len=%s type=%s",
                                    list(data.keys()),
                                    data.get("counters"),
                                    assets_len,
                                    data.get("type"),
                                )
                                assets_dbg = data.get("assets")
                                if (
                                    isinstance(assets_dbg, list)
                                    and assets_dbg
                                    and isinstance(assets_dbg[0], dict)
                                ):
                                    ui_logger.debug(
                                        "UI first asset keys=%s",
                                        list(assets_dbg[0].keys()),
                                    )
                            except Exception:
                                pass
                            parsed_assets = data.get("assets") or []
                            # –Ø–∫—â–æ –ø—Ä–∏–π—à–æ–≤ –ø–æ—Ä–æ–∂–Ω—ñ–π —Å–ø–∏—Å–æ–∫, –∞–ª–µ –≤–∂–µ –º–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ
                            # –¥–∞–Ω—ñ ‚Äî —ñ–≥–Ω–æ—Ä—É—î–º–æ –æ—á–∏—â–µ–Ω–Ω—è
                            if not parsed_assets and self._display_results:
                                ui_logger.debug(
                                    "Ignore empty assets update; keeping %d cached rows",
                                    len(self._display_results),
                                )
                            else:
                                self._last_results = parsed_assets
                                if parsed_assets:
                                    self._display_results = parsed_assets
                            # meta.ts ‚Üí —á–∞—Å –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
                            meta_ts = data.get("meta", {}).get("ts")
                            if meta_ts:
                                try:
                                    incoming_ts = datetime.fromisoformat(
                                        meta_ts.replace("Z", "")
                                    ).timestamp()
                                    # –û–Ω–æ–≤–ª—é—î–º–æ –ª–∏—à–µ —è–∫—â–æ –Ω–æ–≤—ñ—à–µ –∑–Ω–∞—á–µ–Ω–Ω—è
                                    if incoming_ts >= self.last_update_time:
                                        self.last_update_time = incoming_ts
                                except Exception:
                                    pass
                            else:
                                # Heartbeat –±–µ–∑ meta.ts ‚Äî –æ–Ω–æ–≤–ª—é—î–º–æ —á–∞—Å –ª–∏—à–µ —è–∫—â–æ
                                # –¥–∞–≤–Ω–æ –Ω–µ –æ–Ω–æ–≤–ª—é–≤–∞–ª–æ—Å—å (>5s)
                                if time.time() - self.last_update_time > 5:
                                    self.last_update_time = time.time()
                            # counters ‚Üí –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫—É
                            self._last_counters = data.get("counters", {}) or {}
                            # –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –ª–æ–≥ —É–∑–≥–æ–¥–∂–µ–Ω–æ—Å—Ç—ñ
                            ui_logger.debug(
                                "Post-assign last_results_len=%d counters_assets=%s display_len=%d",
                                len(self._last_results),
                                self._last_counters.get("assets"),
                                len(self._display_results),
                            )
                        # (—Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å –∑—ñ —Å—Ç–∞—Ä–∏–º —Ñ–æ—Ä–º–∞—Ç–æ–º)
                        elif isinstance(data, list):
                            # Legacy format: whole message is just the assets list
                            if data:
                                self._last_results = data
                                self._display_results = data
                                self.last_update_time = time.time()
                            else:
                                ui_logger.debug(
                                    "Legacy empty list ignored; keeping cached results"
                                )

                    # –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –¥–ª—è –≤—Å—ñ—Ö ALERT*
                    for r in self._last_results:
                        sig = str(r.get("signal", "")).upper()
                        if sig.startswith("ALERT"):
                            self.alert_animator.add_alert(r.get("symbol", ""))

                    # –Ø–∫—â–æ counters –∫–∞–∂–µ >0, –∞ —Å–ø–∏—Å–æ–∫ –ø–æ—Ä–æ–∂–Ω—ñ–π ‚Äî –ª–æ–≥/–¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
                    # –í–∏–±—ñ—Ä —Å–ø–∏—Å–∫—É –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è: –∞–±–æ –ø–æ—Ç–æ—á–Ω–∏–π, –∞–±–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –Ω–µ–ø–æ—Ä–æ–∂–Ω—ñ–π
                    results_for_render = (
                        self._last_results
                        if self._last_results
                        else self._display_results
                    )
                    if (
                        not self._last_results
                        and self._last_counters.get("assets", 0) > 0
                        and self._display_results
                    ):
                        ui_logger.warning(
                            "Using cached results_for_render len=%d (last empty, "
                            "counters.assets=%s)",
                            len(self._display_results),
                            self._last_counters.get("assets"),
                        )
                    elif not results_for_render:
                        ui_logger.debug(
                            "Render with empty results_for_render; counters.assets=%s",
                            self._last_counters.get("assets"),
                        )
                    ui_logger.debug(
                        "Render: last=%d cached=%d render=%d last_update_age=%.1fs",
                        len(self._last_results),
                        len(self._display_results),
                        len(results_for_render),
                        time.time() - self.last_update_time,
                    )
                    table = self._build_signal_table(results_for_render)
                    live.update(table)
                    await asyncio.sleep(smooth_delay)

                except (ConnectionError, TimeoutError) as e:
                    ui_logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∑'—î–¥–Ω–∞–Ω–Ω—è: {e}")
                    await asyncio.sleep(3)
                    try:
                        await pubsub.reset()
                        await pubsub.subscribe(channel)
                        ui_logger.info("‚úÖ –ü–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Redis")
                    except Exception as reconnect_err:
                        ui_logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: {reconnect_err}")
                except Exception as e:
                    ui_logger.error(f"–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞: {e}")
                    await asyncio.sleep(1)

    def _build_signal_table(
        self, results: list[dict[str, Any]], loading: bool = False
    ) -> Table:
        """–ü–æ–±—É–¥–æ–≤–∞ —Ç–∞–±–ª–∏—Ü—ñ –∑ —Å–∏–≥–Ω–∞–ª–∞–º–∏ —Ç–∞ –º–µ—Ç—Ä–∏–∫–∞–º–∏ —Å–∏—Å—Ç–µ–º–∏."""
        # counters –∑ payload—É, —è–∫—â–æ —î
        # –°–ø–µ—Ä—à—É –±–µ—Ä–µ–º–æ —Ñ–∞–∫—Ç–∏—á–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤ (—â–æ —Ä–µ–∞–ª—å–Ω–æ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è)
        total_assets = len(results)
        # ALERT –±–µ—Ä–µ–º–æ –∑ counters —è–∫—â–æ —î, —ñ–Ω–∞–∫—à–µ –ø–µ—Ä–µ—Ä–∞—Ö—É—î–º–æ –ª–æ–∫–∞–ª—å–Ω–æ
        alert_count = self._last_counters.get("alerts")
        if alert_count is None:
            alert_count = sum(
                1
                for r in results
                if str(r.get("signal", "")).upper().startswith("ALERT")
            )

        last_update = datetime.fromtimestamp(self.last_update_time).strftime("%H:%M:%S")

        # –ù–æ–≤—ñ —Ç—Ä–µ–π–¥-–º–µ—Ç—Ä–∏–∫–∏ –∑ core (—è–∫—â–æ –±—É–ª–∏ –ø—ñ–¥–≤–∞–Ω—Ç–∞–∂–µ–Ω—ñ)
        active_trades = self._last_counters.get("active_trades")
        closed_trades = self._last_counters.get("closed_trades")
        skipped = self._last_counters.get("skipped")
        skipped_ewma = self._last_counters.get("skipped_ewma")
        drift_ratio = self._last_counters.get("drift_ratio")
        dynamic_interval = self._last_counters.get("dynamic_interval")
        pressure = self._last_counters.get("pressure")
        pressure_norm = self._last_counters.get("pressure_norm")
        th_drift_high = self._last_counters.get("th_drift_high")
        th_drift_low = self._last_counters.get("th_drift_low")
        th_pressure = self._last_counters.get("th_pressure")
        consec_drift = self._last_counters.get("consec_drift_high")
        consec_pressure = self._last_counters.get("consec_pressure_high")
        alpha_val = self._last_counters.get("alpha")
        skip_reasons = self._last_counters.get("skip_reasons")

        # –§–æ—Ä–º–∞—Ç—É—î–º–æ drift (—è–∫—â–æ –±—É–¥–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç–∏—Å—è —á–µ—Ä–µ–∑ stats:core —É –º–∞–π–±—É—Ç–Ω—å–æ–º—É)
        if drift_ratio is not None:
            try:
                drift_val = float(drift_ratio)
                # –Ø–∫—â–æ thresholds –¥–æ—Å—Ç—É–ø–Ω—ñ ‚Äì –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—Ö
                if th_drift_high is not None and th_drift_low is not None:
                    if drift_val < float(th_drift_low):
                        drift_color = (
                            "yellow"  # –∑–∞–Ω–∞–¥—Ç–æ –ø–æ–≤—ñ–ª—å–Ω–æ / –º–∞–ª–æ —á–∞—Å—É? (–Ω–∏–∂–Ω—ñ–π –ø–æ—Ä—ñ–≥)
                        )
                    elif drift_val > float(th_drift_high):
                        drift_color = "red"
                    else:
                        drift_color = "green"
                else:
                    if drift_val < 0.9:
                        drift_color = "green"
                    elif drift_val <= 1.2:
                        drift_color = "yellow"
                    else:
                        drift_color = "red"
                drift_fragment = f" | Drift: [{drift_color}]{drift_val:.2f}[/]"
            except Exception:
                drift_fragment = ""
        else:
            drift_fragment = ""

        trades_fragment = ""
        if active_trades is not None or closed_trades is not None:
            trades_fragment = (
                f" | Trades: üü¢{active_trades or 0}/üî¥{closed_trades or 0}"
            )
        # –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è skipped / ewma
        if skipped is not None:
            skipped_fragment = f" | Skipped: {skipped}"
            if skipped_ewma is not None:
                try:
                    skipped_ewma_val = float(skipped_ewma)
                    color = (
                        "green"
                        if skipped_ewma_val < 1
                        else ("yellow" if skipped_ewma_val < 3 else "red")
                    )
                    skipped_fragment += f" (EWMA: [{color}]{skipped_ewma_val:.2f}[/])"
                except Exception:
                    pass
        else:
            skipped_fragment = ""

        if dynamic_interval is not None:
            try:
                dyn_val = float(dynamic_interval)
                dyn_color = (
                    "green"
                    if dyn_val
                    <= 1.1 * (self._last_counters.get("cycle_interval") or dyn_val)
                    else (
                        "yellow"
                        if dyn_val
                        <= 2.0 * (self._last_counters.get("cycle_interval") or dyn_val)
                        else "red"
                    )
                )
                dynamic_fragment = f" | ŒîInterval: [{dyn_color}]{dyn_val:.1f}s[/]"
            except Exception:
                dynamic_fragment = f" | ŒîInterval: {dynamic_interval}"
        else:
            dynamic_fragment = ""

        blink_fragment = ""
        if pressure is not None:
            try:
                p_val = float(pressure)
                if th_pressure is not None:
                    th_pressure_f = float(th_pressure)
                    if p_val > th_pressure_f:
                        p_color = "red"
                        self._pressure_alert_active = True
                    elif p_val > th_pressure_f * 0.7:
                        p_color = "yellow"
                        self._pressure_alert_active = False
                    else:
                        p_color = "green"
                        self._pressure_alert_active = False
                else:
                    p_color = (
                        "green" if p_val < 0.5 else ("yellow" if p_val < 1.5 else "red")
                    )
                    self._pressure_alert_active = p_color == "red"
                pressure_fragment = f" | Pressure: [{p_color}]{p_val:.2f}[/]"
                if pressure_norm is not None:
                    try:
                        pn = float(pressure_norm)
                        pressure_fragment += f"(n={pn:.2f})"
                    except Exception:
                        pass
                # –ú–∏–≥–æ—Ç—ñ–Ω–Ω—è
                if self._pressure_alert_active:
                    self._blink_state = not self._blink_state
                    if self._blink_state:
                        blink_fragment = " [blink][red]‚ö†[/][/blink]"
            except Exception:
                pressure_fragment = f" | Pressure: {pressure}"
        else:
            pressure_fragment = ""

        consec_fragment = ""
        if (consec_drift or consec_pressure) and (consec_drift or 0) + (
            consec_pressure or 0
        ) > 0:
            consec_fragment = (
                f" | Seq(drift/press): {consec_drift or 0}/{consec_pressure or 0}"
            )
        alpha_fragment = (
            f" | Œ±={alpha_val:.2f}" if isinstance(alpha_val, (int, float)) else ""
        )
        skip_reasons_fragment = ""
        if isinstance(skip_reasons, dict) and skip_reasons:
            # take first 3 reasons for compact display
            top_pairs = list(skip_reasons.items())[:3]
            compact = ",".join(f"{k}:{v}" for k, v in top_pairs)
            skip_reasons_fragment = f" | SkipReasons[{compact}]"

        title = (
            f"[bold]–°–∏—Å—Ç–µ–º–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É AiOne_t[/bold] | "
            f"–ê–∫—Ç–∏–≤–∏: [green]{total_assets}[/green] | "
            f"ALERT: [red]{alert_count}[/red] | "
            f"–û–Ω–æ–≤–ª–µ–Ω–æ: [cyan]{last_update}[/cyan]"
            f"{trades_fragment}{skipped_fragment}{drift_fragment}{dynamic_fragment}{pressure_fragment}{consec_fragment}{alpha_fragment}{skip_reasons_fragment}{blink_fragment}"
        )

        table = Table(
            title=title,
            box=ROUNDED,
            show_header=True,
            header_style="bold magenta",
            expand=True,
        )

        columns = [
            ("–°–∏–º–≤–æ–ª", "left"),
            ("–¶—ñ–Ω–∞", "right"),
            ("–û–±–æ—Ä–æ—Ç USD", "right"),
            ("ATR%", "right"),
            ("RSI", "right"),
            ("–°—Ç–∞—Ç—É—Å", "center"),
            ("–ü—Ä–∏—á–∏–Ω–∏", "left"),
            ("–°–∏–≥–Ω–∞–ª", "center"),
            ("Conf%", "right"),
            ("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è", "left"),
            ("TP/SL", "right"),
        ]
        for header, justify in columns:
            j = (
                "left"
                if justify == "left"
                else "right" if justify == "right" else "center"
            )
            table.add_column(
                header,
                justify=cast(Literal["default", "left", "center", "right", "full"], j),
            )

        if loading or not results:
            # –ú–∞—Ä–∫–∞–ø Rich –º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏: –≤—ñ–¥–∫—Ä–∏–ª–∏ [cyan] ‚Äî –∑–∞–∫—Ä–∏–ª–∏ [/cyan]
            table.add_row(
                "[cyan]üîÑ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö...[/cyan]", *[""] * (len(columns) - 1)
            )
            return table

        def priority_key(r: dict) -> tuple:
            stats = r.get(K_STATS, {})
            reasons = set(r.get(K_TRIGGER_REASONS, []))
            is_alert = str(r.get(K_SIGNAL, "")).upper().startswith("ALERT")
            anomaly = (stats.get("volume_z", 0.0) or 0.0) >= self.vol_z_threshold
            warning = (not is_alert) and bool(reasons)
            if is_alert and "volume_spike" in reasons:
                cat = 0
            elif is_alert:
                cat = 1
            elif anomaly:
                cat = 2
            elif warning:
                cat = 3
            else:
                cat = 4
            return (cat, -(stats.get("volume_mean", 0.0) or 0.0))

        try:
            sorted_results = sorted(results, key=priority_key)
        except Exception as e:
            ui_logger.debug("Sorting failed: %s", e)
            sorted_results = results

        for asset in sorted_results:
            symbol = str(asset.get(K_SYMBOL, "")).upper()
            stats = asset.get(K_STATS, {}) or {}

            # –ü–µ—Ä–µ–≤–∞–≥–∞ –ø–ª–æ—Å–∫–∏—Ö –∫–ª—é—á—ñ–≤ —è–∫—â–æ –≤–æ–Ω–∏ –≤–∂–µ —Ä–æ–∑—Ä–∞—Ö–æ–≤–∞–Ω—ñ –ø—Ä–æ–¥—é—Å–µ—Ä–æ–º
            if "price_str" in asset and isinstance(asset.get("price_str"), str):
                price_str = asset["price_str"]
                try:
                    cp_raw = asset.get("price", stats.get("current_price"))
                    current_price = float(cp_raw) if cp_raw is not None else None
                except Exception:
                    current_price = None
            else:
                try:
                    if "price" in asset and isinstance(
                        asset.get("price"), (int, float)
                    ):
                        price_val = asset.get("price")
                        current_price = (
                            float(price_val) if price_val is not None else None
                        )
                    else:
                        cp_raw = stats.get("current_price")
                        current_price = float(cp_raw) if cp_raw is not None else None
                except Exception:
                    current_price = None
                price_str = self._format_price(current_price, symbol)

            volume = asset.get("volume")
            if not isinstance(volume, (int, float)):
                volume = stats.get("volume_mean", 0.0) or 0.0
            volume_z = stats.get("volume_z", 0.0) or 0.0
            if "volume_str" in asset and isinstance(asset.get("volume_str"), str):
                volume_str = asset["volume_str"]
            else:
                volume_str = f"{volume:,.0f}"
            if volume_z > self.vol_z_threshold:
                volume_str = f"[bold magenta]{volume_str}[/]"

            if "atr_pct" in asset and isinstance(asset.get("atr_pct"), (int, float)):
                atr_pct = float(asset.get("atr_pct") or 0.0)
            else:
                atr_raw = stats.get("atr")
                try:
                    atr = float(atr_raw) if atr_raw is not None else None
                except Exception:
                    atr = None
                atr_pct = (
                    (float(atr) / float(current_price) * 100.0)
                    if (
                        atr is not None
                        and current_price is not None
                        and current_price > 0
                    )
                    else 0.0
                )
            atr_color = self._get_atr_color(atr_pct)
            if atr_color:
                atr_str = f"[{atr_color}]{atr_pct:.2f}%[/]"
            else:
                atr_str = f"{atr_pct:.2f}%"

            rsi_val = asset.get("rsi")
            if not isinstance(rsi_val, (int, float)):
                rsi_val = stats.get("rsi")
            try:
                rsi_f = float(rsi_val) if rsi_val is not None else None
            except Exception:
                rsi_f = None
            if rsi_f is None:
                rsi_str = "-"
            else:
                rsi_color = self._get_rsi_color(float(rsi_f))
                if rsi_color:
                    rsi_str = f"[{rsi_color}]{float(rsi_f):.1f}[/]"
                else:
                    rsi_str = f"{float(rsi_f):.1f}"

            status = asset.get("status") or asset.get("state", "normal")
            if status == "normal":
                status_icon = "üü¢"
            elif status == "init":
                status_icon = "üü®"
            else:
                status_icon = "üî¥"
            status_str = f"{status_icon} {status}"

            signal = str(asset.get(K_SIGNAL, "NONE")).upper()
            signal_str = f"{self._get_signal_icon(signal)} {signal}"

            # –ù–æ–≤–∞ –∫–æ–ª–æ–Ω–∫–∞ –≤–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ (confidence)
            conf_val = asset.get("confidence")
            if not isinstance(conf_val, (int, float)):
                conf_val = 0.0
            conf_str = f"{float(conf_val)*100:.1f}%"

            # ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è –±–µ—Ä–µ—Ç—å—Å—è –∑ –∫–æ—Ä–µ–Ω—è, –∞ –Ω–µ –∑ stage2_result
            recommendation = str(asset.get("recommendation", "-"))
            rec_str = (
                f"{self._get_recommendation_icon(recommendation)} {recommendation}"
            )

            if "tp_sl" in asset:
                tp_sl_str = asset.get("tp_sl") or "-"
            else:
                tp = asset.get("tp")
                sl = asset.get("sl")
                tp_sl_str = (
                    f"TP: {self._format_price(tp, symbol)}\nSL: {self._format_price(sl, symbol)}"
                    if tp and sl
                    else "-"
                )

            # –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –¥–ª—è ALERT*
            row_style = (
                "bold red"
                if signal.startswith("ALERT")
                and self.alert_animator.should_highlight(symbol)
                else ""
            )

            tags = []
            for reason in asset.get(K_TRIGGER_REASONS, []) or []:
                tags.append(
                    "[magenta]–°–ø–ª–µ—Å–∫ –æ–±—Å—è–≥—É[/]"
                    if reason == "volume_spike"
                    else f"[yellow]{reason}[/]"
                )
            reasons = "  ".join(tags) or "-"

            table.add_row(
                symbol,
                price_str,
                volume_str,
                atr_str,
                rsi_str,
                status_str,
                reasons,
                signal_str,
                conf_str,
                rec_str,
                tp_sl_str,
                style=row_style,
            )

        return table


async def main() -> None:
    consumer = UIConsumer()
    await consumer.redis_consumer()


if __name__ == "__main__":
    asyncio.run(main())
