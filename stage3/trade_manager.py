"""Stage3 TradeLifecycleManager.

–£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –∂–∏—Ç—Ç—î–≤–∏–º —Ü–∏–∫–ª–æ–º —É–≥–æ–¥:
    ‚Ä¢ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è —Ç–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –∑–∞ –ø—Ä–∞–≤–∏–ª–∞–º–∏;
    ‚Ä¢ trailing (trail);
    ‚Ä¢ –¥–æ—Å—Ç—Ä–æ–∫–æ–≤—ñ –≤–∏—Ö–æ–¥–∏;
    ‚Ä¢ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ñ –∞–¥–∞–ø—Ç–∞—Ü—ñ—ó.

–°—Ç–∏–ª—å:
    ‚Ä¢ –∫–æ—Ä–æ—Ç–∫—ñ —Å–µ–∫—Ü—ñ–π–Ω—ñ —Ö–µ–¥–µ—Ä–∏;
    ‚Ä¢ guard –¥–ª—è –ª–æ–≥–µ—Ä–∞;
    ‚Ä¢ –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ –¥–æ broad except.
"""

from __future__ import annotations

import asyncio
import json
import logging
import uuid
from collections.abc import Mapping
from datetime import datetime
from typing import Any, Protocol

import pandas as pd

from utils.utils import safe_float

# ‚îÄ‚îÄ Logger ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logger = logging.getLogger("stage3.trade_manager")
if not logger.handlers:  # guard –≤—ñ–¥ –¥—É–±–ª—é–≤–∞–Ω–Ω—è
    logger.setLevel(logging.DEBUG)
    try:
        from rich.console import Console
        from rich.logging import RichHandler

        logger.addHandler(RichHandler(console=Console(stderr=True), show_path=False))
    except Exception:  # broad except: rich –æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–∏–π
        logger.addHandler(logging.StreamHandler())
    logger.propagate = False


# ‚îÄ‚îÄ –õ–æ–∫–∞–ª—å–Ω—ñ —Ö–µ–ª–ø–µ—Ä–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def as_float(value: object, default: float = 0.0) -> float:
    """–ü—Ä–∏–≤–æ–¥–∏—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –¥–æ float —á–µ—Ä–µ–∑ safe_float, –ø—ñ–¥—Å—Ç–∞–≤–ª—è—î default, —è–∫—â–æ None.

    Args:
        value: –í—Ö—ñ–¥–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (–±—É–¥—å-—â–æ, —â–æ –º–æ–∂–µ –±—É—Ç–∏ float).
        default: –ó–Ω–∞—á–µ–Ω–Ω—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º, —è–∫—â–æ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –Ω–µ–º–æ–∂–ª–∏–≤–∞.

    Returns:
        float: –ö–æ—Ä–µ–∫—Ç–Ω–∏–π float (–∞–±–æ default).
    """
    v = safe_float(value)
    if v is None:
        return default
    return v


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –°—Ç–∞—Ç—É—Å–∏ —É–≥–æ–¥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
TRADE_STATUS: dict[str, str] = {
    "OPEN": "open",
    "CLOSED_TP": "closed_tp",
    "CLOSED_SL": "closed_sl",
    "CLOSED_MANUAL": "closed_manual",
    "CLOSED_TIMEOUT": "closed_timeout",
    "CLOSED_BY_SIGNAL": "closed_by_signal",
    "CLOSED_BY_CLUSTER": "closed_by_cluster",
}


def utc_now() -> str:
    """–ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Ç–æ—á–Ω–∏–π —á–∞—Å –≤ UTC —É —Ñ–æ—Ä–º–∞—Ç—ñ ISO —ñ–∑ —Å—É—Ñ—ñ–∫—Å–æ–º 'Z'."""
    return datetime.utcnow().isoformat() + "Z"


class Trade:
    """
    –ú–æ–¥–µ–ª—å —Ç–æ—Ä–≥–æ–≤–æ—ó —É–≥–æ–¥–∏.

    Attributes:
        id: –£–Ω—ñ–∫–∞–ª—å–Ω–∏–π —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä.
        symbol: –¢–æ—Ä–≥–æ–≤–∏–π —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç.
        entry_price: –¶—ñ–Ω–∞ –≤—Ö–æ–¥—É.
        tp: Take Profit.
        sl: Stop Loss.
        status: –ü–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞—Ç—É—Å.
        open_time: –ß–∞—Å –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è.
        close_time: –ß–∞—Å –∑–∞–∫—Ä–∏—Ç—Ç—è.
        exit_reason: –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è.
        result: –§—ñ–Ω–∞–ª—å–Ω–∏–π P&L (%).
        strategy: –Ü–º'—è —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó.
        confidence: –†—ñ–≤–µ–Ω—å –≤–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ —Å–∏–≥–Ω–∞–ª—É.
        indicators: ATR, RSI, Volume –Ω–∞ –≤—Ö–æ–¥—ñ.
        updates: –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ–¥—ñ–π (open, update, trailing_stop —Ç–æ—â–æ).
        current_price: –û—Å—Ç–∞–Ω–Ω—è –≤—ñ–¥–æ–º–∞ —Ü—ñ–Ω–∞.
        close_price: –¶—ñ–Ω–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è.
        predicted_profit: –ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∏–π –ø—Ä–æ—Ñ—ñ—Ç (%) –Ω–∞ –º–æ–º–µ–Ω—Ç –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è.
    """

    def __init__(self, signal: dict[str, Any], strategy: str = "default") -> None:
        # –£–Ω—ñ–∫–∞–ª—å–Ω–∏–π —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —É–≥–æ–¥–∏
        self.id: str = f"{signal.get('symbol','?')}_{uuid.uuid4().hex}"
        # –û—Å–Ω–æ–≤–Ω—ñ –∞—Ç—Ä–∏–±—É—Ç–∏
        self.symbol: str = signal.get("symbol", "")
        self.entry_price: float = as_float(signal.get("current_price"), 0.0)
        self.tp: float = as_float(signal.get("tp"), 0.0)
        self.sl: float = as_float(signal.get("sl"), 0.0)
        self.strategy: str = strategy
        self.confidence: float = as_float(signal.get("confidence", 0.0), 0.0)
        # –ö–ª–∞—Å—Ç–µ—Ä–Ω—ñ —Ñ–∞–∫—Ç–æ—Ä–∏, –∑–Ω–∞–π–¥–µ–Ω—ñ –ø–∞—Ç–µ—Ä–Ω–∏ —Ç–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
        self.cluster_factors: list[str] = signal.get("cluster_factors", [])
        self.patterns: list[str] = signal.get("patterns", [])
        self.context_confirmations: list[str] = signal.get("context_confirmations", [])
        # –°—Ç–∞—Ç—É—Å —Ç–∞ —á–∞—Å–æ–≤—ñ –º—ñ—Ç–∫–∏
        self.status: str = TRADE_STATUS["OPEN"]
        self.open_time: str = utc_now()
        self.close_time: str | None = None
        self.exit_reason: str | None = None
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç, —â–æ –º–æ–∂–µ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏ EnhancedContextAwareTradeManager
        self.context: dict[str, Any] = {}
        # –¶—ñ–Ω–∏ —Ç–∞ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä–∏
        self.current_price: float = self.entry_price
        self.close_price: float | None = None
        self.indicators: dict[str, float] = {
            "atr": as_float(signal.get("atr"), 0.0),
            "rsi": as_float(signal.get("rsi"), 0.0),
            "volume": as_float(signal.get("volume"), 0.0),
        }
        # –ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω–∏–π –ø—Ä–∏–±—É—Ç–æ–∫ (%) –Ω–∞ –º–æ–º–µ–Ω—Ç –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è
        if self.entry_price == 0:
            self.predicted_profit = 0.0
        elif self.tp >= self.entry_price:
            self.predicted_profit = (
                (self.tp - self.entry_price) / self.entry_price * 100
            )
        else:
            self.predicted_profit = (
                (self.entry_price - self.tp) / self.entry_price * 100
            )

        # –§—ñ–Ω–∞–ª—å–Ω–∏–π P&L (%) ‚Äî —Å–ø–æ—á–∞—Ç–∫—É None, –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –ø—Ä–∏ –∑–∞–∫—Ä–∏—Ç—Ç—ñ
        self.result: float | None = None

        # –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ–¥—ñ–π (open, update, trailing_stop —Ç–æ—â–æ)
        self.updates: list[dict[str, Any]] = []
        self._log_event("open", self._snapshot())
        logger.info(
            "üîî –í—ñ–¥–∫—Ä–∏—Ç–æ —É–≥–æ–¥—É %s: factors=%s patterns=%s conf=%.2f TP=%.4f SL=%.4f",
            self.id,
            self.cluster_factors,
            self.patterns,
            self.confidence,
            self.tp,
            self.sl,
        )

    def _snapshot(self) -> dict[str, Any]:
        """–ü–æ—Ç–æ—á–Ω–∏–π –∑—Ä—ñ–∑ —Å—Ç–∞–Ω—É —É–≥–æ–¥–∏ (–¥–ª—è –ª–æ–≥—É–≤–∞–Ω–Ω—è)."""
        return {
            "symbol": self.symbol,
            "side": self.side,
            "entry_price": self.entry_price,
            "tp": self.tp,
            "sl": self.sl,
            "status": self.status,
            "open_time": self.open_time,
            "current_price": self.current_price,
            "max_profit": self.max_profit,
            "cluster_factors": self.cluster_factors,
            "patterns": self.patterns,
            "context_confirmations": self.context_confirmations,
        }

    @property
    def side(self) -> str:
        """–ù–∞–ø—Ä—è–º–æ–∫ —É–≥–æ–¥–∏ (buy —è–∫—â–æ TP>=entry, —ñ–Ω–∞–∫—à–µ sell)."""
        return "buy" if self.tp >= self.entry_price else "sell"

    @property
    def max_profit(self) -> float:
        """–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –ø—Ä–æ—Ñ—ñ—Ç (%) –≤—ñ–¥ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –¥–æ —Ç–µ–ø–µ—Ä—ñ—à–Ω—å–æ—ó —Ü—ñ–Ω–∏."""
        if self.entry_price == 0:
            return 0.0
        if self.side == "buy":
            return (self.current_price - self.entry_price) / self.entry_price * 100
        return (self.entry_price - self.current_price) / self.entry_price * 100

    def _log_event(self, event: str, data: dict[str, Any]) -> None:
        """–î–æ–¥–∞—î –∑–∞–ø–∏—Å –≤ —ñ—Å—Ç–æ—Ä—ñ—é –ø–æ–¥—ñ–π, —Ñ—ñ–∫—Å—É—î –ø–æ—Ç–æ—á–Ω–∏–π SL/TP."""
        data["sl"] = self.sl  # –§—ñ–∫—Å—É—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π SL
        data["tp"] = self.tp  # –§—ñ–∫—Å—É—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π TP
        record = {"event": event, "timestamp": utc_now(), **data}
        self.updates.append(record)

    def to_dict(self) -> dict[str, Any]:
        """–ü–æ–≤–µ—Ä—Ç–∞—î –ø–æ–≤–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è —É–≥–æ–¥–∏ –¥–ª—è –∑–∞–ø–∏—Å—É –≤ –ª–æ–≥."""
        base = self._snapshot()
        base.update(
            {
                "id": self.id,
                "strategy": self.strategy,
                "confidence": self.confidence,
                "predicted_profit": self.predicted_profit,
                "close_time": self.close_time,
                "exit_reason": self.exit_reason,
                "result": self.result,
                "close_price": self.close_price,
                "indicators": self.indicators,
                "updates": self.updates,
            }
        )
        return base


class TradeRule:
    """–Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —É–≥–æ–¥–∏."""

    async def __call__(self, trade: Trade, market: dict[str, Any]) -> None:
        raise NotImplementedError


class ContextExitRule(TradeRule):
    """–ü—Ä–∞–≤–∏–ª–æ –∑–∞–∫—Ä–∏—Ç—Ç—è –ø—Ä–∏ –∑–º—ñ–Ω—ñ —Ä–∏–Ω–∫–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É."""

    async def __call__(self, trade: Trade, market: dict[str, Any]) -> None:
        # –Ø–∫—â–æ market –º—ñ—Å—Ç–∏—Ç—å –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –∫–æ–Ω—Ç—Ä-—Ç—Ä–µ–Ω–¥—É ‚Üí –∑–∞–∫—Ä–∏—Ç–∏
        if market.get("context_break", False):
            trade.status = TRADE_STATUS["CLOSED_BY_SIGNAL"]
            trade.exit_reason = "context_break"
            trade._log_event("exit_context", {"reason": "context_break"})
            logger.info("‚ùå –£–≥–æ–¥–∞ %s –∑–∞–∫—Ä–∏—Ç–∞ —á–µ—Ä–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç (context_break)", trade.id)


class TrailingStopRule(TradeRule):
    """
    –ü—Ä–∞–≤–∏–ª–æ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–Ω—è SL —É –±—ñ–∫ —Ü—ñ–Ω–∏ –≤—Ö–æ–¥—É, —Ç—ñ–ª—å–∫–∏ –ø—ñ—Å–ª—è
    –∑–Ω–∞—á–Ω–æ–≥–æ —Ä—É—Ö—É (buffer_size).

    –õ–æ–≥—ñ–∫–∞:
      –¥–ª—è buy:
        - —è–∫—â–æ price < entry_price + buffer_size ‚Üí —Ç—Ä–µ–π–ª –Ω–µ –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è
        - target_sl = price - buffer_size
        - new_sl = max(old_sl, target_sl), –∞–ª–µ –Ω–µ –≤–∏—â–µ entry_price
      –¥–ª—è sell:
        - —è–∫—â–æ price > entry_price - buffer_size ‚Üí —Ç—Ä–µ–π–ª –Ω–µ –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è
        - target_sl = price + buffer_size
        - new_sl = min(old_sl, target_sl), –∞–ª–µ –Ω–µ –Ω–∏–∂—á–µ entry_price
    """

    def __init__(self, atr_buffer: float = 0.3) -> None:
        """
        Args:
            atr_buffer: –º–Ω–æ–∂–Ω–∏–∫ –≤—ñ–¥ ATR, —è–∫–∏–π –≤–∏–∑–Ω–∞—á–∞—î
                        –¥–∏—Å—Ç–∞–Ω—Ü—ñ—é –ø–µ—Ä–µ–¥ –ø–µ—Ä—à–∏–º —Ç—Ä–µ–π–ª–æ–º
        """
        self.atr_buffer = atr_buffer
        self.logger = logging.getLogger(f"{__name__}.TrailingStopRule")
        logger.setLevel(logging.DEBUG)

    async def __call__(self, trade: Trade, market: dict[str, Any]) -> None:
        # –Ü–≥–Ω–æ—Ä—É—î–º–æ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ñ —É–≥–æ–¥–∏
        if trade.status != TRADE_STATUS["OPEN"]:
            return

        # –ó–∞–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ
        price = as_float(market.get("price"), 0.0)
        atr = trade.indicators.get("atr", 0.0)
        if atr <= 0:
            return

        buffer_size = atr * self.atr_buffer
        old_sl = trade.sl

        if trade.side == "buy":
            # –°—Ç–∞—Ä—Ç —Ç—Ä–µ–π–ª–∞ ‚Äî —Ç—ñ–ª—å–∫–∏ –ø—ñ—Å–ª—è price ‚â• entry_price + buffer_size
            if price < trade.entry_price + buffer_size:
                return
            target_sl = price - buffer_size
            # –ü–µ—Ä–µ–º—ñ—â–∞—î–º–æ —Å—Ç–æ–ø –≤–≥–æ—Ä—É, –∞–ª–µ –Ω–µ –≤–∏—â–µ entry_price
            new_sl = max(old_sl, target_sl)
            new_sl = min(new_sl, trade.entry_price)

        else:  # sell
            if price > trade.entry_price - buffer_size:
                return
            target_sl = price + buffer_size
            # –ü–µ—Ä–µ–º—ñ—â–∞—î–º–æ —Å—Ç–æ–ø –≤–Ω–∏–∑, –∞–ª–µ –Ω–µ –Ω–∏–∂—á–µ entry_price
            new_sl = min(old_sl, target_sl)
            new_sl = max(new_sl, trade.entry_price)

        # –Ø–∫—â–æ SL –∑–º—ñ–Ω–∏–≤—Å—è ‚Äî –ª–æ–≥ —ñ –ø–æ–¥—ñ—è
        if new_sl != old_sl:
            trade.sl = new_sl
            trade._log_event(
                "trailing_stop",
                {"old_sl": old_sl, "new_sl": new_sl, "timestamp": utc_now()},
            )
            self.logger.debug(
                "üõ° TRAIL-STOP %s: %.6f ‚Üí %.6f (price=%.6f, atr=%.6f, buffer=%.6f)",
                trade.id,
                old_sl,
                new_sl,
                price,
                atr,
                buffer_size,
            )


class EarlyExitRule(TradeRule):
    """–ü—Ä–∞–≤–∏–ª–æ –¥–æ—Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –∑–∞–∫—Ä–∏—Ç—Ç—è –∑–∞ –∑–≤–æ—Ä–æ—Ç–Ω–æ—é –∑–º—ñ–Ω–æ—é –æ–±—Å—è–≥—É/RSI."""

    async def __call__(self, trade: Trade, market: dict[str, Any]) -> None:
        vol = as_float(market.get("volume"), 0.0)
        rsi = as_float(market.get("rsi"), 0.0)
        if trade.side == "buy" and vol < trade.indicators["volume"] * 0.7 and rsi < 50:
            trade.status = TRADE_STATUS["CLOSED_BY_SIGNAL"]
            trade.exit_reason = "early_exit"
            trade._log_event("early_exit", {"vol": vol, "rsi": rsi})
            logger.info("üîª –£–≥–æ–¥–∞ %s early exit (vol drop & RSI)", trade.id)
        if trade.side == "sell" and vol < trade.indicators["volume"] * 0.7 and rsi > 50:
            trade.status = TRADE_STATUS["CLOSED_BY_SIGNAL"]
            trade.exit_reason = "early_exit"
            trade._log_event("early_exit", {"vol": vol, "rsi": rsi})
            logger.info("üî∫ –£–≥–æ–¥–∞ %s early exit (vol drop & RSI)", trade.id)


class TradeLifecycleManager:
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä –∂–∏—Ç—Ç—î–≤–æ–≥–æ —Ü–∏–∫–ª—É —É–≥–æ–¥–∏.

    –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î asyncio.Lock –¥–ª—è –ø–æ—Ç–æ–∫–æ–±–µ–∑–ø–µ—á–Ω–æ—Å—Ç—ñ,
    cooldown –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è
    —Ç–∞ –∑–±–∏—Ä–∞—î –ø—ñ–¥—Å—É–º–∫–æ–≤—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–æ–∂–Ω–æ—ó —É–≥–æ–¥–∏.
    """

    def __init__(
        self,
        log_file: str = "trade_log.jsonl",
        summary_file: str = "summary_log.jsonl",
        reopen_cooldown: float = 60.0,  # —Å–µ–∫—É–Ω–¥–∏
        max_parallel_trades: int = 3,  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö —É–≥–æ–¥
    ) -> None:
        self.active_trades: dict[str, Trade] = {}
        self.closed_trades: list[dict[str, Any]] = []
        self.reopen_cooldown = reopen_cooldown
        self.max_parallel_trades = max_parallel_trades
        self.recently_closed: dict[str, str] = {}  # symbol ‚Üí ISO close_time
        self.log_file = log_file
        self.summary_file = summary_file
        # –û–Ω–æ–≤–ª–µ–Ω—ñ –ø—Ä–∞–≤–∏–ª–∞ –≤–∫–ª—é—á–∞—é—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∏–π –≤–∏—Ö—ñ–¥
        self.rules: list[TradeRule] = [
            ContextExitRule(),
            TrailingStopRule(),
            EarlyExitRule(),
        ]
        self.lock = asyncio.Lock()

    async def open_trade(
        self, signal: dict[str, Any], strategy: str = "default"
    ) -> str | None:
        """
        –í—ñ–¥–∫—Ä–∏–≤–∞—î —É–≥–æ–¥—É, —è–∫—â–æ –¥–ª—è —Å–∏–º–≤–æ–ª–∞ –Ω–µ–º–∞ open-—É–≥–æ–¥–∏
        —ñ —è–∫—â–æ –Ω–µ –≤ cooldown –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –∑–∞–∫—Ä–∏—Ç—Ç—è.
        –î–æ–¥–∞—î –æ–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö —É–≥–æ–¥.

        Returns:
            id –≤—ñ–¥–∫—Ä–∏—Ç–æ—ó –∞–±–æ —ñ—Å–Ω—É—é—á–æ—ó —É–≥–æ–¥–∏, –∞–±–æ None —è–∫—â–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ.
        """
        async with self.lock:
            sym = signal["symbol"]
            logger.debug("–°–ø—Ä–æ–±–∞ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è —É–≥–æ–¥–∏ –¥–ª—è %s –∑—ñ —Å–∏–≥–Ω–∞–ª–æ–º: %s", sym, signal)

            # 0) –æ–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö —É–≥–æ–¥
            if len(self.active_trades) >= self.max_parallel_trades:
                logger.info(
                    "SKIP OPEN ‚ùå %s: –¥–æ—Å—è–≥–Ω—É—Ç–æ –ª—ñ–º—ñ—Ç—É –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö —É–≥–æ–¥ (%d)",
                    sym,
                    self.max_parallel_trades,
                )
                return None

            # 1) cooldown –ø—ñ—Å–ª—è –∑–∞–∫—Ä–∏—Ç—Ç—è
            last = self.recently_closed.get(sym)
            if last:
                t0 = datetime.fromisoformat(last.rstrip("Z"))
                if (datetime.utcnow() - t0).total_seconds() < self.reopen_cooldown:
                    logger.info("SKIP OPEN ‚ùå %s: –≤ cooldown (–∑–∞–∫—Ä–∏—Ç–∞ %s)", sym, last)
                    return None

            # 2) —è–∫—â–æ –≤–∂–µ —î open-—É–≥–æ–¥–∞ ‚Äî –Ω–µ –≤—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ –Ω–æ–≤—É
            for tr in self.active_trades.values():
                if tr.symbol == sym and tr.status == TRADE_STATUS["OPEN"]:
                    logger.info(
                        "SKIP OPEN ‚ùå %s: –≤–∂–µ –º–∞—î –≤—ñ–¥–∫—Ä–∏—Ç—É —É–≥–æ–¥—É id=%s",
                        sym,
                        tr.id,
                    )
                    return tr.id

            # 3) —ñ–Ω–∞–∫—à–µ –≤—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ
            trade = Trade(signal, strategy)
            self.active_trades[trade.id] = trade

            # –õ–æ–≥ —Ñ–∞–π–ª—É
            await self._persist(self.log_file, trade.to_dict())

            logger.info(
                "OPENED ‚úÖ %s: id=%s, entry_price=%.6f, tp=%.6f, sl=%.6f",
                sym,
                trade.id,
                trade.entry_price,
                trade.tp,
                trade.sl,
            )
            logger.debug("OPEN DETAIL ‚ñ∂ %s", trade.to_dict())

            return trade.id

    async def update_trade(self, trade_id: str, market: dict[str, Any]) -> bool:
        """
        –û–Ω–æ–≤–ª—é—î —Å—Ç–∞–Ω —É–≥–æ–¥–∏: —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä–∏, –ø—Ä–∞–≤–∏–ª–∞, TP/SL, timeout.

        Returns:
            True —è–∫—â–æ —É–≥–æ–¥–∞ –∑–∞–∫—Ä–∏–ª–∞—Å—è –≤ —Ü—å–æ–º—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ.
        """
        async with self.lock:
            tr = self.active_trades.get(trade_id)
            if not tr or tr.status != TRADE_STATUS["OPEN"]:
                logger.debug(
                    "UPDATE SKIP üîÑ %s: –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤—ñ–¥–∫—Ä–∏—Ç—É —É–≥–æ–¥—É –∞–±–æ status‚â†OPEN",
                    trade_id,
                )
                return False

            tr.current_price = as_float(market.get("price"), 0.0)
            logger.debug(
                "UPDATE ‚ñ∫ %s: –Ω–æ–≤–∞ –ø–æ—Ç–æ—á–Ω–∞ —Ü—ñ–Ω–∞ = %.6f",
                trade_id,
                tr.current_price,
            )

            # –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –∫–æ–∂–Ω–æ–≥–æ –ø—Ä–∞–≤–∏–ª–∞
            for rule in self.rules:
                logger.debug(
                    "–ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –ø—Ä–∞–≤–∏–ª–æ %s –¥–æ %s", rule.__class__.__name__, trade_id
                )
                await rule(tr, market)

            closed = await self._check_exit(tr)
            logger.debug(
                "RESULT ‚ñ∂ %s: status=%s, closed=%s",
                trade_id,
                tr.status,
                closed,
            )

            # –ª–æ–≥ –ø–æ–¥—ñ—ó
            tr._log_event("update", {"price": tr.current_price, "status": tr.status})
            await self._persist(self.log_file, tr.to_dict())
            logger.debug("UPDATED ‚ñ∫ %s", tr.to_dict())

            if closed:
                # –ø—Ä–∏–±–∏—Ä–∞—î–º–æ –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö
                self.active_trades.pop(trade_id, None)
                logger.info(
                    "TRADE CLOSED ‚úÖ %s: –ø—Ä–∏—á–∏–Ω–∞='%s'", trade_id, tr.exit_reason
                )

            return closed

    async def close_trade(self, trade_id: str, price: float, reason: str) -> None:
        """
        –†—É—á–Ω–µ –∑–∞–∫—Ä–∏—Ç—Ç—è —É–≥–æ–¥–∏.

        Args:
            price: –¶—ñ–Ω–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è.
            reason: –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è.
        """
        async with self.lock:
            tr = self.active_trades.pop(trade_id, None)
            if not tr:
                logger.warning("CLOSE SKIP ‚ö†Ô∏è %s: —É–≥–æ–¥–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞", trade_id)
                return

            tr.status = TRADE_STATUS["CLOSED_MANUAL"]
            tr.exit_reason = reason
            tr.close_price = price
            tr.close_time = utc_now()
            tr.result = TradeLifecycleManager.calculate_profit(tr, price)

            # –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —á–∞—Å –¥–ª—è cooldown
            self.recently_closed[tr.symbol] = tr.close_time

            logger.info(
                "CLOSE ‚óÄ %s: price=%.6f, reason=%s, result=%.2f%%",
                trade_id,
                price,
                reason,
                tr.result,
            )
            logger.debug("CLOSE DETAIL ‚óÄ %s", tr.to_dict())

            # –∑–∞–ø–∏—Å –ø–æ–≤–Ω–æ–≥–æ –ª–æ–≥—É
            await self._persist(self.log_file, tr.to_dict())

            # –∑–∞–ø–∏—Å summary
            summary = self._make_summary(tr)
            await self._persist(self.summary_file, summary)
            logger.info("SUMMARY ‚úçÔ∏è %s", summary)

    async def _check_exit(self, tr: Trade) -> bool:
        """
        –ü–µ—Ä–µ–≤—ñ—Ä—è—î TP/SL —Ç–∞ —ñ–Ω—à—ñ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω—ñ —Å—Ç–∞—Ç—É—Å–∏,
        –∑–∞—Å—Ç–æ—Å–æ–≤—É—î timeout —ñ –∑–∞–ø–∏—Å—É—î summary –ø—Ä–∏ –∑–∞–∫—Ä–∏—Ç—Ç—ñ.
        """
        p = tr.current_price
        now = datetime.utcnow()

        # TP
        if tr.side == "buy" and p >= tr.tp:
            tr.status, tr.exit_reason = TRADE_STATUS["CLOSED_TP"], "TP"
        elif tr.side == "sell" and p <= tr.tp:
            tr.status, tr.exit_reason = TRADE_STATUS["CLOSED_TP"], "TP"
        # SL
        elif tr.side == "buy" and p <= tr.sl:
            tr.status, tr.exit_reason = TRADE_STATUS["CLOSED_SL"], "SL"
        elif tr.side == "sell" and p >= tr.sl:
            tr.status, tr.exit_reason = TRADE_STATUS["CLOSED_SL"], "SL"
        # timeout
        elif (now - datetime.fromisoformat(tr.open_time.rstrip("Z"))).seconds > 3600:
            tr.status, tr.exit_reason = TRADE_STATUS["CLOSED_TIMEOUT"], "timeout"
        else:
            if tr.status != TRADE_STATUS["OPEN"]:
                # –ø—Ä–∞–≤–∏–ª–æ –∑–º—ñ–Ω–∏–ª–æ —Å—Ç–∞—Ç—É—Å –≤—Ä—É—á–Ω—É
                pass
            else:
                return False

        # –∑–∞–ø–æ–≤–Ω—é—î–º–æ –ø–æ–ª—è –∑–∞–∫—Ä–∏—Ç—Ç—è
        tr.close_price = p
        tr.close_time = utc_now()
        tr.result = TradeLifecycleManager.calculate_profit(tr, p)
        # cooldown
        self.recently_closed[tr.symbol] = tr.close_time

        # –∑–∞–ø–∏—Å full-detail
        await self._persist(self.log_file, tr.to_dict())
        # –∑–∞–ø–∏—Å summary
        await self._persist(self.summary_file, self._make_summary(tr))

        # –¥–æ–¥–∞—î–º–æ –≤ closed_trades –¥–ª—è –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–≥–æ –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è
        self.closed_trades.append(tr.to_dict())
        return True

    @staticmethod
    def calculate_profit(tr: Trade, price: float) -> float:
        """Profit (%) –¥–ª—è buy/sell."""
        if tr.entry_price == 0:
            return 0.0
        if tr.side == "buy":
            return (price - tr.entry_price) / tr.entry_price * 100
        return (tr.entry_price - price) / tr.entry_price * 100

    def _make_summary(self, tr: Trade) -> dict[str, Any]:
        """
        –§–æ—Ä–º—É—î –ø—ñ–¥—Å—É–º–∫–æ–≤–∏–π –∑–∞–ø–∏—Å –¥–ª—è summary_log.jsonl
        """
        return {
            "id": tr.id,
            "symbol": tr.symbol,
            "strategy": tr.strategy,
            "confidence": tr.confidence,
            "open_time": tr.open_time,
            "entry_price": tr.entry_price,
            "predicted_profit": tr.predicted_profit,
            "close_time": tr.close_time,
            "close_price": tr.close_price,
            "exit_reason": tr.exit_reason,
            "realized_profit": tr.result,
            "events_count": len(tr.updates),
        }

    async def _persist(self, file_path: str, data: dict[str, Any]) -> None:
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∑–∞–ø–∏—Å—É—î JSONL —É –≤–∫–∞–∑–∞–Ω–∏–π —Ñ–∞–π–ª."""
        loop = asyncio.get_event_loop()
        line = json.dumps(data, ensure_ascii=False) + "\n"
        await loop.run_in_executor(None, self._write_sync, file_path, line)

    def _write_sync(self, file_path: str, line: str) -> None:
        with open(file_path, "a", encoding="utf-8") as f:
            f.write(line)

    async def get_active_trades(self) -> list[dict[str, Any]]:
        """–ü–æ–≤–µ—Ä—Ç–∞—î –∫–æ–ø—ñ—é –∞–∫—Ç–∏–≤–Ω–∏—Ö —É–≥–æ–¥."""
        async with self.lock:
            return [tr.to_dict() for tr in self.active_trades.values()]

    async def get_closed_trades(self) -> list[dict[str, Any]]:
        """–ü–æ–≤–µ—Ä—Ç–∞—î –∫–æ–ø—ñ—é –∑–∞–∫—Ä–∏—Ç–∏—Ö —É–≥–æ–¥."""
        async with self.lock:
            return list(self.closed_trades)


class EnhancedContextAwareTradeManager(TradeLifecycleManager):
    class _ContextEngineProto(Protocol):
        async def evaluate_context(self, symbol: str) -> dict[str, Any]: ...

        def get_last_bar(self, symbol: str) -> dict[str, object]: ...

        def load_data(self, symbol: str, interval: str = ...) -> object: ...

    def __init__(
        self,
        context_engine: _ContextEngineProto,
        *,
        log_file: str = "trade_log.jsonl",
        summary_file: str = "summary_log.jsonl",
        reopen_cooldown: float = 60.0,
        max_parallel_trades: int = 3,
    ) -> None:
        super().__init__(
            log_file=log_file,
            summary_file=summary_file,
            reopen_cooldown=reopen_cooldown,
            max_parallel_trades=max_parallel_trades,
        )
        self.context_engine: EnhancedContextAwareTradeManager._ContextEngineProto = (
            context_engine
        )
        # –î–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –¥–ª—è –∫–µ—Ä—É–≤–∞–Ω–Ω—è —á—É—Ç–ª–∏–≤—ñ—Å—Ç—é
        self.volatility_threshold = 0.005
        self.phase_change_threshold = 0.5

    async def manage_active_trades(self) -> None:
        """–ü–µ—Ä—ñ–æ–¥–∏—á–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–∏—Ö —É–≥–æ–¥ –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—É"""
        while True:
            for trade_id in list(self.active_trades.keys()):
                trade = self.active_trades[trade_id]
                try:
                    # –û—Ç—Ä–∏–º–∞–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –∑ –æ–±—Ä–æ–±–∫–æ—é –ø–æ–º–∏–ª–æ–∫
                    context = await self.context_engine.evaluate_context(trade.symbol)

                    # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∑–º—ñ–Ω–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
                    if self.has_context_changed_significantly(trade, context):
                        await self.close_trade(
                            trade_id, trade.current_price, "context_change"
                        )
                        continue

                    # –ê–¥–∞–ø—Ç–∞—Ü—ñ—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —É–≥–æ–¥–∏
                    self.adapt_trade_parameters(trade, context)

                    # –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ä–∏–Ω–∫–æ–≤–∏–º–∏ –¥–∞–Ω–∏–º–∏
                    market_data = self.get_market_data(trade.symbol)
                    await self.update_trade(trade_id, market_data)
                except Exception as e:  # broad except: —ñ–∑–æ–ª—è—Ü—ñ—è –æ–¥–Ω—ñ—î—ó —É–≥–æ–¥–∏
                    logger.error(f"Error managing trade {trade_id}: {e}")

            await asyncio.sleep(60)

    def has_context_changed_significantly(
        self, trade: Trade, new_context: dict[str, Any]
    ) -> bool:
        """–í–∏–∑–Ω–∞—á–∞—î —á–∏ –∑–º—ñ–Ω–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –≤–∏–º–∞–≥–∞—î –∑–∞–∫—Ä–∏—Ç—Ç—è —É–≥–æ–¥–∏"""
        old_context = getattr(trade, "context", {})
        old_phase = old_context.get("market_phase", "")
        new_phase = new_context["market_phase"]

        # –ö—Ä–∏—Ç–∏—á–Ω—ñ –∑–º—ñ–Ω–∏ –º—ñ–∂ –ø—Ä–æ—Ç–∏–ª–µ–∂–Ω–∏–º–∏ —Å—Ç–∞–Ω–∞–º–∏
        critical_changes = {
            ("strong_uptrend", "strong_downtrend"),
            ("strong_downtrend", "strong_uptrend"),
            ("accumulation_phase", "distribution"),
            ("volatility_compression", "volatility_expansion"),
            ("price_compression", "price_expansion"),
        }

        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –ø–µ—Ä–µ—Ö–æ–¥—ñ–≤
        if (old_phase, new_phase) in critical_changes:
            return True

        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∑—Å—É–≤—É –∫–ª—é—á–æ–≤–∏—Ö —Ä—ñ–≤–Ω—ñ–≤
        old_levels = set(old_context.get("key_levels", []))
        new_levels = set(new_context["key_levels"])

        if old_levels and new_levels:
            # –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Å–µ—Ä–µ–¥–Ω—å–æ—ó –∑–º—ñ–Ω–∏ —Ä—ñ–≤–Ω—ñ–≤
            avg_change = sum(
                abs(new - old)
                for new, old in zip(sorted(new_levels), sorted(old_levels), strict=True)
            ) / len(old_levels)

            if avg_change / trade.entry_price > 0.03:
                return True

        # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä—ñ–∑–∫–æ—ó –∑–º—ñ–Ω–∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ
        old_volatility = old_context.get("volatility", 0)
        new_volatility = new_context["volatility"]
        if abs(new_volatility - old_volatility) > self.volatility_threshold * 3:
            return True

        return False

    def adapt_trade_parameters(self, trade: Trade, context: dict[str, Any]) -> None:
        """–ê–¥–∞–ø—Ç–∞—Ü—ñ—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —É–≥–æ–¥–∏ –¥–æ –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É"""
        new_volatility = context["volatility"]
        old_context = getattr(trade, "context", {})
        old_volatility = old_context.get("volatility", 0)
        phase = context["market_phase"]

        # –ö–æ—Ä–µ–∫—Ü—ñ—è —Ç—ñ–ª—å–∫–∏ –ø—Ä–∏ –∑–Ω–∞—á–Ω—ñ–π –∑–º—ñ–Ω—ñ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ
        if abs(new_volatility - old_volatility) > self.volatility_threshold:
            # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –∫–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è
            volatility_ratio = (
                new_volatility / old_volatility if old_volatility > 0 else 1.0
            )

            # –î–ª—è —Ç—Ä–µ–Ω–¥–æ–≤–∏—Ö —Å—Ç–∞–Ω—ñ–≤ - –±—ñ–ª—å—à –∞–≥—Ä–µ—Å–∏–≤–Ω–∞ –∫–æ—Ä–µ–∫—Ü—ñ—è
            if "trend" in phase:
                tp_adjust = volatility_ratio**0.8
                sl_adjust = volatility_ratio**1.2
            # –î–ª—è –∫–æ–Ω—Å–æ–ª—ñ–¥–∞—Ü—ñ—ó - –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–∞ –∫–æ—Ä–µ–∫—Ü—ñ—è
            else:
                tp_adjust = volatility_ratio**0.5
                sl_adjust = volatility_ratio**0.8

            # –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –∫–æ—Ä–µ–∫—Ü—ñ—é –¥–æ TP/SL
            trade.tp = trade.entry_price + (trade.tp - trade.entry_price) * tp_adjust
            trade.sl = trade.entry_price - (trade.entry_price - trade.sl) * sl_adjust

            trade._log_event(
                "parameters_adjusted",
                {
                    "reason": "volatility_change",
                    "new_volatility": new_volatility,
                    "old_volatility": old_volatility,
                    "tp_adjust": tp_adjust,
                    "sl_adjust": sl_adjust,
                },
            )

        # –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –≤ —É–≥–æ–¥—ñ
        trade.context = {
            "market_phase": phase,
            "key_levels": context["key_levels"],
            "volatility": new_volatility,
            "cluster_indicators": context["cluster_indicators"],
            "sentiment": context.get("sentiment", 0),
            "timestamp": datetime.utcnow().isoformat(),
        }

        # –î–æ–¥–∞—Ç–∫–æ–≤–∞ –∫–æ—Ä–µ–∫—Ü—ñ—è –¥–ª—è —Å—Ç–∏—Å–Ω–µ–Ω–∏—Ö —Ä–∏–Ω–∫—ñ–≤
        if "compression" in phase:
            # –ó–º–µ–Ω—à—É—î–º–æ TP —Ç–∞ —Ä–æ–∑—à–∏—Ä—é—î–º–æ SL –¥–ª—è –±—ñ–ª—å—à –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–æ—ó —Å—Ç—Ä–∞—Ç–µ–≥—ñ—ó
            trade.tp = trade.entry_price + (trade.tp - trade.entry_price) * 0.8
            trade.sl = trade.entry_price - (trade.entry_price - trade.sl) * 1.2
            trade._log_event(
                "compression_adjust",
                {
                    "reason": "market_compression",
                    "new_tp": trade.tp,
                    "new_sl": trade.sl,
                },
            )

    def get_market_data(self, symbol: str) -> dict[str, float]:
        """–ü–æ–∫—Ä–∞—â–µ–Ω–µ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–∏–Ω–∫–æ–≤–∏—Ö –¥–∞–Ω–∏—Ö –∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É/–±—É—Ñ–µ—Ä–∞/–±—ñ—Ä–∂—ñ"""
        # –°–ø—Ä–æ–±—É—î–º–æ –æ—Ç—Ä–∏–º–∞—Ç–∏ –æ—Å—Ç–∞–Ω–Ω—ñ–π –±–∞—Ä –∑ context_engine (—è–∫—â–æ —î –º–µ—Ç–æ–¥)
        try:
            if hasattr(self.context_engine, "get_last_bar"):
                raw = self.context_engine.get_last_bar(symbol)
                bar: Mapping[str, object] = raw  # –æ—á—ñ–∫—É—î–º–æ –º–∞–ø—É —ñ–∑ —á–∏—Å–ª–æ–≤–∏–º–∏ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏
                price = as_float(bar.get("close", 0.0), 0.0)
                volume = as_float(bar.get("volume", 0.0), 0.0)
                rsi = as_float(bar.get("rsi", 0.0), 0.0)
                ask = as_float(bar.get("ask", 0.0), 0.0)
                bid = as_float(bar.get("bid", 0.0), 0.0)
                spread = abs(ask - bid) if (ask and bid) else 0.0
                return {
                    "price": price,
                    "volume": volume,
                    "rsi": rsi,
                    "bid_ask_spread": spread,
                }
            else:
                df_obj = self.context_engine.load_data(symbol, "1m")
                if isinstance(df_obj, pd.DataFrame) and not df_obj.empty:
                    row = df_obj.iloc[-1]
                    price = float(row.get("close", 0.0))
                    volume = float(row.get("volume", 0.0))
                    rsi = float(row.get("rsi", 0.0))
                    ask = float(row.get("ask", 0.0)) if "ask" in row else 0.0
                    bid = float(row.get("bid", 0.0)) if "bid" in row else 0.0
                    spread = abs(ask - bid) if (ask and bid) else 0.0
                    return {
                        "price": price,
                        "volume": volume,
                        "rsi": rsi,
                        "bid_ask_spread": spread,
                    }
                return {"price": 0.0, "volume": 0.0, "rsi": 0.0, "bid_ask_spread": 0.0}
        except Exception as e:
            logger.error(
                f"[TradeManager] –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ä–∏–Ω–∫–æ–≤—ñ –¥–∞–Ω—ñ –¥–ª—è {symbol}: {e}"
            )
            return {"price": 0.0, "volume": 0.0, "rsi": 0.0, "bid_ask_spread": 0.0}

    def get_current_price(self, symbol: str) -> float:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ—ó —Ü—ñ–Ω–∏ –∑ context_engine (–æ—Å—Ç–∞–Ω–Ω—è —Ü—ñ–Ω–∞ close)"""
        try:
            df_obj = self.context_engine.load_data(symbol)
            if isinstance(df_obj, pd.DataFrame) and not df_obj.empty:
                return float(df_obj.iloc[-1]["close"])
        except Exception as e:  # broad except: —Ç—ñ–ª—å–∫–∏ –ª–æ–≥ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            logger.error(f"get_current_price error for {symbol}: {e}")
        return 0.0

    def get_current_volume(self, symbol: str) -> float:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ –æ–±—Å—è–≥—É –∑ context_engine (–æ—Å—Ç–Ω—ñ–π bar volume)"""
        try:
            df_obj = self.context_engine.load_data(symbol)
            if isinstance(df_obj, pd.DataFrame) and not df_obj.empty:
                return float(df_obj.iloc[-1]["volume"])
        except Exception as e:  # broad except: —Ç—ñ–ª—å–∫–∏ –ª–æ–≥ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            logger.error(f"get_current_volume error for {symbol}: {e}")
        return 0.0

    def get_current_rsi(self, symbol: str) -> float:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ RSI –∑ context_engine (–æ—Å—Ç–Ω—ñ–π bar rsi)"""
        try:
            df_obj = self.context_engine.load_data(symbol)
            if (
                isinstance(df_obj, pd.DataFrame)
                and not df_obj.empty
                and "rsi" in df_obj.columns
            ):
                return float(df_obj.iloc[-1]["rsi"])
        except Exception as e:  # broad except: —Ç—ñ–ª—å–∫–∏ –ª–æ–≥ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            logger.error(f"get_current_rsi error for {symbol}: {e}")
        return 0.0

    def get_bid_ask_spread(self, symbol: str) -> float:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–ø—Ä–µ–¥—É –∑ context_engine (bid/ask —è–∫—â–æ —î, —ñ–Ω–∞–∫—à–µ 0)"""
        try:
            df_obj = self.context_engine.load_data(symbol)
            if (
                isinstance(df_obj, pd.DataFrame)
                and not df_obj.empty
                and "bid" in df_obj.columns
                and "ask" in df_obj.columns
            ):
                bid = float(df_obj.iloc[-1]["bid"])
                ask = float(df_obj.iloc[-1]["ask"])
                return abs(ask - bid)
        except Exception as e:  # broad except: —Ç—ñ–ª—å–∫–∏ –ª–æ–≥ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            logger.error(f"get_bid_ask_spread error for {symbol}: {e}")
        return 0.0
